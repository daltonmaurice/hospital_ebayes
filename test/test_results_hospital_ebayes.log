----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      name:  <unnamed>
       log:  /Users/mad265/git-pub/hospital_ebayes/test/test_results_hospital_ebayes.log
  log type:  text
 opened on:  25 Mar 2025, 20:22:53

. 
. * Load ado file once at the start
. mata: mata clear

. do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // Convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
272. }
273. else {
274.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(leaveout_years[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[2]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
. * Helper program to check correlation
. capture program drop check_correlation

. program define check_correlation
  1.     args var1 var2 threshold
  2.     corr `var1' `var2'
  3.     if abs(r(rho) - 1) >= `threshold' {
  4.         di as error "Correlation test failed. Expected correlation near 1, got: " r(rho)
  5.         exit 9
  6.     }
  7.     di "✓ Correlation between `var1' and `var2': " r(rho)
  8. end

. 
. * Test counter
. local test_number = 0

. local failed_tests = 0

. 
. * Test 1: Basic Functionality
. local ++test_number

. di _n "Test `test_number': Basic Functionality"

Test 1: Basic Functionality

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "merge tv"
  - if inlist("`1'","preserve","merge") {
  = if inlist("merge","preserve","merge") {
  - restore
  - if (`merge_resid'==1) {
  = if (0==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
  - if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
  = if (1==1) qui merge m:1 id year   using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', nogen nolabel
  - }
  - else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
. }

. if _rc {
.     local ++failed_tests
.     di as error "Test `test_number' failed with error code: " _rc
. }

. else di "✓ Test `test_number' passed"
✓ Test 1 passed

. 
. * Test 2: Controls
. local ++test_number

. di _n "Test `test_number': Controls"

Test 2: Controls

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) controls(xb) data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00980658
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.0993099 0 4.9993154 1.0048913
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9474962639   .6271572506         76000  |
   2 |  .9041990824   .5987675557         72000  |
   3 |  .8539651463   .5660651337         68000  |
   4 |  .8129636861   .5396187951         64000  |
   5 |  .7696909688   .5110351293         60000  |
   6 |  .7344070716   .4880445613         56000  |
   7 |  .6929314993   .4601018247         52000  |
   8 |  .6668197919   .4422467161         48000  |
   9 |  .6375668392   .4227240465         44000  |
  10 |  .6094279203   .4036822661         40000  |
  11 |  .5710975987   .3778459174         36000  |
  12 |  .5502558635   .3638015033         32000  |
  13 |  .5179221152   .3415348607         28000  |
  14 |  .4995744235   .3284311271         24000  |
  15 |  .4620997043   .3039484919         20000  |
  16 |  .4424916181   .2906791454         16000  |
  17 |  .4173461483   .2753047922         12000  |
  18 |  .3985586279   .2646395387          8000  |
  19 |  .3834670704   .2575328704          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9474962639  |
   2 |  .9041990824  |
   3 |  .8539651463  |
   4 |  .8129636861  |
   5 |  .7696909688  |
   6 |  .7344070716  |
   7 |  .6929314993  |
   8 |  .6668197919  |
   9 |  .6375668392  |
  10 |  .6094279203  |
  11 |  .5710975987  |
  12 |  .5502558635  |
  13 |  .5179221152  |
  14 |  .4995744235  |
  15 |  .4620997043  |
  16 |  .4424916181  |
  17 |  .4173461483  |
  18 |  .3985586279  |
  19 |  .3834670704  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "merge tv"
  - if inlist("`1'","preserve","merge") {
  = if inlist("merge","preserve","merge") {
  - restore
  - if (`merge_resid'==1) {
  = if (0==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
  - if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
  = if (1==1) qui merge m:1 id year   using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', nogen nolabel
  - }
  - else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
. }

. if _rc {
.     local ++failed_tests
.     di as error "Test `test_number' failed with error code: " _rc
. }

. else di "✓ Test `test_number' passed"
✓ Test 2 passed

. 
. * Test 3: Leave-out Estimators
. local ++test_number

. di _n "Test `test_number': Leave-out Estimators"

Test 3: Leave-out Estimators

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);
. }

. if _rc {
.     local ++failed_tests
.     di as error "Test `test_number' failed with error code: " _rc
Test 3 failed with error code: 3200
. }

. else di "✓ Test `test_number' passed"

. 
. * Test 4: Shrinkage Targets
. local ++test_number

. di _n "Test `test_number': Shrinkage Targets"

Test 4: Shrinkage Targets

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) ///
>         shrinkage_target(z) data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1380.06
       Model |  37259.4559         1  37259.4559   Prob > F        =    0.0000
    Residual |   107993951 3,999,998  26.9985012   R-squared       =    0.0003
-------------+----------------------------------   Adj R-squared   =    0.0003
       Total |   108031210 3,999,999  27.0078093   Root MSE        =     5.196

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9628167   .0259176    37.15   0.000     .9120191    1.013614
       _cons |  -.0000165    .002598    -0.01   0.995    -.0051085    .0050755
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00256308
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1960082 0 5.0986212 1.0012807
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |   .948626844   .6226699706         76000  |
   2 |  .9056807882   .5947068787         72000  |
   3 |  .8539750948   .5613151566         68000  |
   4 |  .8143131433   .5360803462         64000  |
   5 |  .7716806607   .5080665232         60000  |
   6 |  .7344233199   .4837897943         56000  |
   7 |  .6934177835   .4564706405         52000  |
   8 |  .6668374799   .4384357999         48000  |
   9 |  .6384555369   .4197322748         44000  |
  10 |  .6097263761   .4004773563         40000  |
  11 |  .5708565161   .3745240246         36000  |
  12 |  .5525376472    .362357173         32000  |
  13 |  .5175405623   .3385160888         28000  |
  14 |  .4981638979   .3249920589         24000  |
  15 |  .4642698099   .3027684485         20000  |
  16 |  .4410290377   .2870372061         16000  |
  17 |  .4195746968   .2744269545         12000  |
  18 |  .4002724716   .2635140586          8000  |
  19 |  .3870205575   .2573416885          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |   .948626844  |
   2 |  .9056807882  |
   3 |  .8539750948  |
   4 |  .8143131433  |
   5 |  .7716806607  |
   6 |  .7344233199  |
   7 |  .6934177835  |
   8 |  .6668374799  |
   9 |  .6384555369  |
  10 |  .6097263761  |
  11 |  .5708565161  |
  12 |  .5525376472  |
  13 |  .5175405623  |
  14 |  .4981638979  |
  15 |  .4642698099  |
  16 |  .4410290377  |
  17 |  .4195746968  |
  18 |  .4002724716  |
  19 |  .3870205575  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
  = local shrinkage_vars_to_keep z __000006
  - }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv z __000006 
variable z not found
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(111);
. }

. if _rc {
.     local ++failed_tests
.     di as error "Test `test_number' failed with error code: " _rc
Test 4 failed with error code: 111
. }

. else di "✓ Test `test_number' passed"

. 
. * Test 5: Data Handling Options
. foreach opt in "preserve" "tv" "merge tv" "variance" {
  2.     local ++test_number
  3.     di _n "Test `test_number': Data Handling Option - `opt'"
  4.     capture noisily {
  5.         use test.dta, clear
  6.         hospital_ebayes y, hospitalid(id) year(year) data("`opt'")
  7.     }
  8.     if _rc {
  9.         local ++failed_tests
 10.         di as error "Test `test_number' failed with error code: " _rc
 11.     }
 12.     else di "✓ Test `test_number' passed"
 13. }
- foreach opt in "preserve" "tv" "merge tv" "variance" {
- local ++test_number
- di _n "Test `test_number': Data Handling Option - `opt'"
= di _n "Test 5: Data Handling Option - preserve"

Test 5: Data Handling Option - preserve
- capture noisily {
- use test.dta, clear
- hospital_ebayes y, hospitalid(id) year(year) data("`opt'")
= hospital_ebayes y, hospitalid(id) year(year) data("preserve")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("preserve"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("preserve","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "preserve"
  - if ("`1'")=="merge" {
  = if ("preserve")=="merge" {
    if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
    if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
    }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "preserve"
  - if inlist("`1'","preserve","merge") {
  = if inlist("preserve","preserve","merge") {
  - restore
  - if (`merge_resid'==1) {
  = if (0==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
  - if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
  = if (0==1) qui merge m:1 id year   using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', nogen nolabel
  - }
  - else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
- }
- if _rc {
  local ++failed_tests
  di as error "Test `test_number' failed with error code: " _rc
  }
- else di "✓ Test `test_number' passed"
= else di "✓ Test 5 passed"
✓ Test 5 passed
- }
- local ++test_number
- di _n "Test `test_number': Data Handling Option - `opt'"
= di _n "Test 6: Data Handling Option - tv"

Test 6: Data Handling Option - tv
- capture noisily {
- use test.dta, clear
- hospital_ebayes y, hospitalid(id) year(year) data("`opt'")
= hospital_ebayes y, hospitalid(id) year(year) data("tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "tv"
  - if ("`1'")=="merge" {
  = if ("tv")=="merge" {
    if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
    if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
    }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "tv"
  - if inlist("`1'","preserve","merge") {
  = if inlist("tv","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
  - else {
  - restore, not
  - if ("`data'"=="tv") use `"`output'"', clear
  = if ("tv"=="tv") use `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', clear
  - }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
- }
- if _rc {
  local ++failed_tests
  di as error "Test `test_number' failed with error code: " _rc
  }
- else di "✓ Test `test_number' passed"
= else di "✓ Test 6 passed"
✓ Test 6 passed
- }
- local ++test_number
- di _n "Test `test_number': Data Handling Option - `opt'"
= di _n "Test 7: Data Handling Option - merge tv"

Test 7: Data Handling Option - merge tv
- capture noisily {
- use test.dta, clear
- hospital_ebayes y, hospitalid(id) year(year) data("`opt'")
= hospital_ebayes y, hospitalid(id) year(year) data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "merge tv"
  - if inlist("`1'","preserve","merge") {
  = if inlist("merge","preserve","merge") {
  - restore
  - if (`merge_resid'==1) {
  = if (0==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
  - if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
  = if (1==1) qui merge m:1 id year   using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', nogen nolabel
  - }
  - else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
- }
- if _rc {
  local ++failed_tests
  di as error "Test `test_number' failed with error code: " _rc
  }
- else di "✓ Test `test_number' passed"
= else di "✓ Test 7 passed"
✓ Test 7 passed
- }
- local ++test_number
- di _n "Test `test_number': Data Handling Option - `opt'"
= di _n "Test 8: Data Handling Option - variance"

Test 8: Data Handling Option - variance
- capture noisily {
- use test.dta, clear
- hospital_ebayes y, hospitalid(id) year(year) data("`opt'")
= hospital_ebayes y, hospitalid(id) year(year) data("variance")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("variance"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("variance","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "variance"
  - if ("`1'")=="merge" {
  = if ("variance")=="merge" {
    if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
    if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
    }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
  - else {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv")
Input vector m dimensions: 1 x 20
  - }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv  
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
  - if (`firstloop'!=1) {
  = if (1!=1) {
    append using `"`output'"', nolabel
    }
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - local firstloop=0
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if "`output_addvars'"!="" quietly {
  = if ""!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
  - sort `hospitalid' `year' `by'
  = sort id year 
  - qui save `"`output'"', replace
  = qui save `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', replace
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
  - else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
  - if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
  = if (1!=1) qui outsheet using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_variance.csv"', comma replace
  - tokenize "`data'"
  = tokenize "variance"
  - if inlist("`1'","preserve","merge") {
  = if inlist("variance","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
  - else {
  - restore, not
  - if ("`data'"=="tv") use `"`output'"', clear
  = if ("variance"=="tv") use `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001"', clear
  - }
  - if (`nooutput'!=1) log close t
  = if (1!=1) log close t
  - }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
- }
- if _rc {
  local ++failed_tests
  di as error "Test `test_number' failed with error code: " _rc
  }
- else di "✓ Test `test_number' passed"
= else di "✓ Test 8 passed"
✓ Test 8 passed
- }

. 
. * Test 6: Error Cases - Invalid driftlimit
. local ++test_number

. di _n "Test `test_number': Error Cases - Invalid driftlimit"

Test 9: Error Cases - Invalid driftlimit

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) driftlimit(999)
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if (""!="") {
    local n_rules = 0
    foreach rule in `leaveout_years' {
    local ++n_rules
    tokenize "`rule'", parse(",")
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if (""=="") local data="preserve"
  - else {
    if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
    else {
    tokenize "`data'"
    if ("`1'")=="merge" {
    if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
    if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
    }
    }
    }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (999<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (999>19) {
  - di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
  = di as error "error: driftlimit(999) was specified, which is greater than the number of lags (19) in the data."
error: driftlimit(999) was specified, which is greater than the number of lags (19) in the data.
  - exit 499
    }
    mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
    if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
    else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
    di "Standard deviations: total, classes, students, Hospital same year"
    if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
    else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
    di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
    mata:CC[.,1..3]
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    if (`driftlimit'>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
    mata:check_m_nomissing(m)
    if (`firstloop'==1) {
    mata:cov_lag_accum= CC[.,1]
    mata:corr_lag_accum= CC[.,2]
    mata:obs_lag_accum= CC[.,3]
    mata:cov_se_lag_accum= CC[.,4]
    mata:var_total_accum= st_numscalar("`var_total'")
    mata:var_class_accum= st_numscalar("`var_class'")
    mata:var_ind_accum= st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum=.
    mata:corr_sameyear_accum=.
    mata:obs_sameyear_accum=0
    }
    else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
    }
    else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
    sort `hospitalid' `year'
    tempvar obs_hosp
    by `hospitalid': egen `obs_hosp'=count(`hospitalid')
    qui gen float tv=.
    if ("`leaveout_years'"!="") {
    local n_rules = wordcount("`leaveout_years'")
    mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
    mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(499);
. }

. if _rc != 499 {  // Expecting specific error code 499
.     local ++failed_tests
.     di as error "Test `test_number' failed: Expected error 499, got " _rc
. }

. else di "✓ Test `test_number' passed"
✓ Test 9 passed

. 
. * Test 7: Error Cases - Invalid variable names
. local ++test_number

. di _n "Test `test_number': Error Cases - Invalid variable names"

Test 10: Error Cases - Invalid variable names

. capture noisily {
.     use test.dta, clear
.     gen tv = 1
.     hospital_ebayes y, hospitalid(id) year(year)
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
  - di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
The dataset loaded in memory when vam is run cannot have a variable named tv.
  - exit 110
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(110);
. }

. if _rc != 110 {  // Expecting specific error code 110 for variable already exists
.     local ++failed_tests
.     di as error "Test `test_number' failed: Expected error 110, got " _rc
. }

. else di "✓ Test `test_number' passed"
✓ Test 10 passed

. 
. * Test 8: Combined Features
. local ++test_number

. di _n "Test `test_number': Combined Features"

Test 11: Combined Features

. capture noisily {
.     use test.dta, clear
.     hospital_ebayes y, hospitalid(id) year(year) ///
>         controls(xb) ///
>         leaveout_years("-1,1") leaveout_vars("tv_1yr") ///
>         shrinkage_target(z) ///
>         data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/1 {
  - local var_`i' "``i''"
  = local var_1 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1426.22
       Model |  37072.7593         1  37072.7593   Prob > F        =    0.0000
    Residual |   103974720 3,999,998   25.993693   R-squared       =    0.0004
-------------+----------------------------------   Adj R-squared   =    0.0004
       Total |   104011793 3,999,999  26.0029547   Root MSE        =    5.0984

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9604015   .0254308    37.77   0.000     .9105581    1.010245
       _cons |  -.0000164   .0025492    -0.01   0.995    -.0050127    .0049799
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00053839
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.098401 0 4.9993154 1.0002692
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9476917857   .6312018312         76000  |
   2 |  .9044250969    .602734024         72000  |
   3 |  .8527268125   .5689088551         68000  |
   4 |  .8125903186   .5429125543         64000  |
   5 |  .7695101294    .514201128         60000  |
   6 |  .7336665729   .4905786896         56000  |
   7 |  .6927342957   .4628665781         52000  |
   8 |   .666811696   .4449626476         48000  |
   9 |  .6377754865   .4254554887         44000  |
  10 |  .6084897402   .4055486704         40000  |
  11 |  .5701441751   .3795639897         36000  |
  12 |  .5496269473   .3656412528         32000  |
  13 |  .5171823385   .3430774965         28000  |
  14 |  .4989734741   .3300388215         24000  |
  15 |  .4624820673    .305849515         20000  |
  16 |  .4413674262   .2912868009         16000  |
  17 |  .4185891693   .2773554005         12000  |
  18 |  .3995607205   .2664730047          8000  |
  19 |  .3838734619    .259079548          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9476917857  |
   2 |  .9044250969  |
   3 |  .8527268125  |
   4 |  .8125903186  |
   5 |  .7695101294  |
   6 |  .7336665729  |
   7 |  .6927342957  |
   8 |   .666811696  |
   9 |  .6377754865  |
  10 |  .6084897402  |
  11 |  .5701441751  |
  12 |  .5496269473  |
  13 |  .5171823385  |
  14 |  .4989734741  |
  15 |  .4624820673  |
  16 |  .4413674262  |
  17 |  .4185891693  |
  18 |  .3995607205  |
  19 |  .3838734619  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-1,1"), tokens("tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);
. }

. if _rc {
.     local ++failed_tests
.     di as error "Test `test_number' failed with error code: " _rc
Test 11 failed with error code: 3200
. }

. else di "✓ Test `test_number' passed"

. 
. * Final test results
. di _n "Test Summary"

Test Summary

. di "=============="
==============

. di "Total tests run: `test_number'"
Total tests run: 11

. di "Tests failed: `failed_tests'"
Tests failed: 3

. 
. if `failed_tests' > 0 {
.     di as error "Some tests failed. Check log for details."
Some tests failed. Check log for details.
.     exit 9
r(9);
. }
r(9);

end of do-file

r(9);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742949394553.do

. 
. * Test 3: Leave-out Estimators
. local ++test_number
local macro `test_number' not found
r(111);

end of do-file

r(111);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742949406492.do

.    use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742949711700.do

.   use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742949761793.do

.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742949953410.do

.    use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. set tracedepth 3

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742950555604.do

.  hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__000000"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __000000
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _ggroup.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_ggroup.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"id year"' == "_all" | `"id year"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
      local byopt "by(`_byvars')"
      local cma ","
      }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __000000
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __000001
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("group","mode","concat","group") {
    - local vv : display "version " string(`cvers') ", missing:"
    = local vv : display "version " string(10.2) ", missing:"
    - }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily version 10.2, missing: _ggroup float __000002 = (id year)     
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __000002 __000000
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
  - di as error "The dataset loaded in memory cannot have a variable named ``i''."
  = di as error "The dataset loaded in memory cannot have a variable named tv_2yr."
The dataset loaded in memory cannot have a variable named tv_2yr.
  - exit 110
    }
    qui gen float ``i'' = .
    }
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(110);

end of do-file

r(110);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742950565868.do

. use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__000000"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __000000
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _ggroup.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_ggroup.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"id year"' == "_all" | `"id year"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
      local byopt "by(`_byvars')"
      local cma ","
      }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __000000
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __000001
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("group","mode","concat","group") {
    - local vv : display "version " string(`cvers') ", missing:"
    = local vv : display "version " string(10.2) ", missing:"
    - }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily version 10.2, missing: _ggroup float __000002 = (id year)     
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __000002 __000000
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
    ------------------------------------------------------------------------------------------------------------------------------------------------------------ begin predict ---
    - version 8.2, missing
    - if "`e(cmd)'" == "rocreg" & "`e(predict)'" == "" {
    = if "regress" == "rocreg" & "regres_p" == "" {
      di as err "predict not allowed after nonparametric ROC"
      exit 198
      }
    - if "`e(mi)'"!="" & "`e(b)'"!="matrix" {
    = if ""!="" & "matrix"!="matrix" {
      error 321
      }
    - if _caller()<=5 | "`e(predict)'"=="" {
    = if _caller()<=5 | "regres_p"=="" {
      _predict `0'
      }
    - else {
    - local v : display string(_caller())
    - version `v', missing
    = version 10.2, missing
    - `e(predict)' `0'
    = regres_p score_r1 if e(sample),r
    - }
    -------------------------------------------------------------------------------------------------------------------------------------------------------------- end predict ---
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__000003"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __000003
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gcount.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gcount.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"score_r"' == "_all" | `"score_r"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id year __000000)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __000003
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __000004
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("count","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gcount float __000005 = (score_r)   , by(id year __000000) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __000005 __000003
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__000004"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __000004
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gmean.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gmean.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"score_r"' == "_all" | `"score_r"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id year __000000)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __000004
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __000007
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("mean","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gmean float __000008 = (score_r)   , by(id year __000000) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __000008 __000004
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
    ----------------------------------------------------------------------------------------------------------------------------------------------------------- begin collapse ---
    - version 8, missing
    - if _caller() < 5 {
      collaps4 `0'
      exit
      }
    - collapse_17 `0'
    = collapse_17 (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
    - if "`col17_graphbar'" != "" {
    = if "" != "" {
      c_local `col17_graphbar' "``col17_graphbar''"
      }
    ------------------------------------------------------------------------------------------------------------------------------------------------------------- end collapse ---
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
    -------------------------------------------------------------------------------------------------------------------------------------------------------------- begin tsset ---
    - version 10
    - capture syntax [, MI noQUERY PANELNAME(passthru) DISPLAYINDENT(passthru) NOBLANK ]
    - if (_rc==0) {
      if ("`mi'"=="") {
      u_mi_not_mi_set tsset
      }
      _ts tvar pvar, panel
      local fmt: format `tvar'
      local tsdelta : char _dta[_TSdelta]
      if "`tsdelta'" == "" {
      local tsdelta 1
      }
      tsset `pvar' `tvar', format(`fmt') delta((`tsdelta')) `mi' `query' `panelname' `displayindent' `noblank'
      ret add
      exit
      }
    - syntax [varlist(numeric max=2 default=none)] [, CLEAR Daily Format(passthru) Generic Halfyearly Monthly Quarterly Weekly Yearly DELta(passthru) Clocktime FORCE MI noQUERY P
> ANELNAME(passthru) DISPLAYINDENT(passthru) PANELLABEL(passthru) TSVARLABEL(passthru) NOBLANK ]
    - if ("`mi'"=="") {
    = if (""=="") {
    - u_mi_not_mi_set tsset
    - }
    - else {
      u_mi_check_setvars tsset `varlist'
      }
    - if ("`clear'" != "") {
    = if ("" != "") {
      syntax [, CLEAR MI]
      Clear
      exit
      }
    - if ("`varlist'"=="") {
    = if ("id year"=="") {
      _ts tvar pvar, panel
      tsset `pvar' `tvar', `daily' `format' `generic' `halfyearly' `monthly' `quarterly' `weekly' `yearly' `clocktime' `mi' `delta' `query' `panelname' `displayindent' `panellabe
> l' `tsvarlabel'
      ret add
      exit
      }
    - syntax varlist(numeric max=2 default=none) [ , CLEAR Daily Format(string) Generic Halfyearly Monthly Quarterly Weekly Yearly DELta(string) Clocktime FORCE MI noQUERY PANELN
> AME(string) DISPLAYINDENT(integer 0) PANELLABEL(string) TSVARLABEL(string) NOBLANK ]
    - local ct : word count `varlist'
    = local ct : word count id year
    - if `ct'==2 {
    = if 2==2 {
    - tokenize `varlist'
    = tokenize id year
    - local panel `1'
    = local panel id
    - local timevar `2'
    = local timevar year
    - }
    - else {
      local timevar `varlist'
      }
    - local period `daily' `weekly' `monthly' `quarterly' `halfyearly' `yearly' `generic' `clocktime'
    = local period        
    - if `"`format'"'!="" {
    = if `""'!="" {
      local dfltfmt "no"
      if "`period'" != "" {
      gettoken period : period
      di in red "may not specify both {bf:format()} and {bf:`period'}"
      exit 198
      }
      local try : di `format' 2
      }
    - else if "`period'" != "" {
    = else if "" != "" {
      local ct : word count `period'
      if `ct' > 1 {
      di as err "{p}may only specify one time-scale from " "{bf:daily}, {bf:weekly}, {bf:monthly}, " "{bf:quarterly}, {bf:halfyearly}, " "{bf:yearly}, and {bf:generic}{p_end}"
      exit 198
      }
      local format = "%t" + bsubstr("`period'",1,1)
      if bsubstr("`period'", 1, 1) == "c" {
      local dfltfmt "yes"
      }
      }
    - else {
    - local format : format `timevar'
    = local format : format year
    - }
    - local curfmt : format `timevar'
    = local curfmt : format year
    - local curftyp = bsubstr("`curfmt'", 2, 1)
    = local curftyp = bsubstr("%10.0g", 2, 1)
    - if "`curftyp'" != "t" & "`curftyp'" != "d" {
    = if "1" != "t" & "1" != "d" {
    - local curftyp g
    - }
    - else if "`curftyp'" == "t" {
    = else if "g" == "t" {
      local curftyp = bsubstr("`curfmt'", 3, 1)
      }
    - local newftyp = bsubstr("`format'", 2, 1)
    = local newftyp = bsubstr("%10.0g", 2, 1)
    - if "`newftyp'" != "t" & "`newftyp'" != "d" {
    = if "1" != "t" & "1" != "d" {
    - local newftyp g
    - }
    - else if "`newftyp'" == "t" {
    = else if "g" == "t" {
      local newftyp = bsubstr("`format'", 3, 1)
      }
    - if "`curftyp'" != "`newftyp'" & "`curftyp'" != "g" {
    = if "g" != "g" & "g" != "g" {
      local shorty = abbrev("`timevar'", 13)
      Period curftyp2 : "" "`curftyp'"
      Period newftyp2 : "" "`newftyp'"
      di as txt "{p 0 9 2}warning: Variable {bf:`shorty'} had been formatted {bf:`curfmt'} " "(a {bf:`curftyp2'} period), and you asked for a {bf:`newftyp2'} period. " "Are you s
> ure that is what you want? Format has been changed. " "{bf:`shorty'} is now formatted {bf:`format'}.{p_end}"
      }
    - else if "`curftyp'" == "`newftyp'" & "`dfltfmt'" != "no" {
    = else if "g" == "g" & "" != "no" {
    - local format `curfmt'
    = local format %10.0g
    - }
    - capture assert int(`timevar')==`timevar'
    = capture assert int(year)==year
    - if _rc {
      di in red "time variable must contain only integer values"
      exit 451
      }
    - sort `panel' `timevar'
    = sort id year
    - if "`panel'" != "" {
    = if "id" != "" {
    - local bypfx "by `panel': "
    = local bypfx "by id: "
    - }
    - if `"`format'"' != "" {
    = if `"%10.0g"' != "" {
    - format `timevar' `format'
    = format year %10.0g
    - }
    - tempname scdelta
    - mata: _TS_p_delta("`scdelta'", "`delta'", "`timevar'")
    = mata: _TS_p_delta("__00000J", "", "year")
    - if `scdelta' == -2 {
    = if __00000J == -2 {
      di as err "invalid time-series format on {bf:`timevar'}"
      exit 120
      }
    - if `scdelta' == -1 {
    = if __00000J == -1 {
      di as err "invalid argument in {bf:delta()}"
      exit 198
      }
    - tempvar timedif
    - qui `bypfx' gen double `timedif' = `timevar'[_n+1] - `timevar'
    = qui by id:  gen double __00000K = year[_n+1] - year
    - cap confirm variable `timedif'
    = cap confirm variable __00000K
    - if _rc {
      di as text "no observations"
      exit
      }
    - qui sum `timedif', meanonly
    = qui sum __00000K, meanonly
    - if r(min) == 0 {
      if "`panel'" != "" {
      di in red "repeated time values within panel"
      }
      else {
      di in red "repeated time values in sample"
      }
      exit 451
      }
    - if "`force'" == "" {
    = if "" == "" {
    - if r(min) < `scdelta' {
    = if r(min) < __00000J {
      di in red "time values with period less than {bf:delta()} found"
      exit 451
      }
    - }
    - Clear
    - nobreak {
    - char _dta[_TStvar] "`timevar'"
    = char _dta[_TStvar] "year"
    - char _dta[_TSpanel] "`panel'"
    = char _dta[_TSpanel] "id"
    - char _dta[_TSdelta] `: di %21x `scdelta''
    = char _dta[_TSdelta] +1.0000000000000X+000
    - char _dta[_TSitrvl] 1
    - char _dta[tis] "`timevar'"
    = char _dta[tis] "year"
    - char _dta[iis] "`panel'"
    = char _dta[iis] "id"
    - }
    - if "`dfltfmt'" == "yes" & bsubstr("`format'", 3, 1) == "c" {
    = if "" == "yes" & bsubstr("%10.0g", 3, 1) == "c" {
      format `timevar' %tcDDmonCCYY_HH:MM:SS.sss
      }
    - if "`query'" == "" {
    = if "" == "" {
    - Query, panelname(`"`panelname'"') displayindent(`displayindent') panellabel(`panellabel') tsvarlabel(`tsvarlabel') `noblank'
    = Query, panelname(`""') displayindent(0) panellabel() tsvarlabel() 
    - ret add
    - }
    - else {
      ret scalar tdelta = `: char _dta[_TSdelta]'
      }
    - if "`dfltfmt'" == "yes" & bsubstr("`format'", 3, 1) == "c" {
    = if "" == "yes" & bsubstr("%10.0g", 3, 1) == "c" {
      format `timevar' %tc
      }
    - local fmt : format `timevar'
    = local fmt : format year
    - return local tsfmt `fmt'
    = return local tsfmt %10.0g
    - return local unit1 = bsubstr("`fmt'", 3, 1)
    = return local unit1 = bsubstr("%10.0g", 3, 1)
    - Period per : "`period'" `return(unit1)'
    = Period per : "" 0
    - return local unit `per'
    = return local unit per : "" 0
    - ret local timevar "`timevar'"
    = ret local timevar "year"
    - ret local panelvar "`panel'"
    = ret local panelvar "id"
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- end tsset ---
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__00000J"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __00000J
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gmin.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gmin.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"year"' == "_all" | `"year"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __00000J
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __00000Q
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("min","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gmin float __00000R = (year)   , by(id) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __00000R __00000J
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__00000K"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __00000K
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gmax.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gmax.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"year"' == "_all" | `"year"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __00000K
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __00000Q
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("max","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gmax float __00000R = (year)   , by(id) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __00000R __00000K
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__00000N"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __00000N
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gmin.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gmin.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"__00000M"' == "_all" | `"__00000M"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __00000N
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __00000Q
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("min","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gmin float __00000R = (__00000M)   , by(id) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __00000R __00000N
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__00000O"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __00000O
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gmax.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gmax.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"__00000M"' == "_all" | `"__00000M"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __00000O
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __00000Q
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("max","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gmax float __00000R = (__00000M)   , by(id) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __00000R __00000O
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f1.__000004 [aw=__000003+f1.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f2.__000004 [aw=__000003+f2.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f3.__000004 [aw=__000003+f3.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f4.__000004 [aw=__000003+f4.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f5.__000004 [aw=__000003+f5.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f6.__000004 [aw=__000003+f6.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f7.__000004 [aw=__000003+f7.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f8.__000004 [aw=__000003+f8.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f9.__000004 [aw=__000003+f9.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f10.__000004 [aw=__000003+f10.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f11.__000004 [aw=__000003+f11.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f12.__000004 [aw=__000003+f12.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f13.__000004 [aw=__000003+f13.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f14.__000004 [aw=__000003+f14.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f15.__000004 [aw=__000003+f15.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f16.__000004 [aw=__000003+f16.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f17.__000004 [aw=__000003+f17.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f18.__000004 [aw=__000003+f18.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
    ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin reg ---
    - if _by() {
      local by "by `_byvars'`_byrc0':"
      }
    - `by' regress `0'
    =  regress __000004 f19.__000004 [aw=__000003+f19.__000003], cluster(id)
    ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end reg ---
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
    --------------------------------------------------------------------------------------------------------------------------------------------------------------- begin egen ---
    - version 6, missing
    - local cvers = _caller()
    - gettoken type 0 : 0, parse(" =(")
    - gettoken name 0 : 0, parse(" =(")
    - if `"`name'"'=="=" {
    = if `"="'=="=" {
    - local name `"`type'"'
    = local name `"__00000Q"'
    - local type : set type
    - }
    - else {
      gettoken eqsign 0 : 0, parse(" =(")
      if `"`eqsign'"' != "=" {
      error 198
      }
      }
    - confirm new variable `name'
    = confirm new variable __00000Q
    - gettoken fcn 0 : 0, parse(" =(")
    - gettoken args 0 : 0, parse(" ,") match(par)
    - if "`c(adoarchive)'"=="1" {
    = if ""=="1" {
      capture qui _stfilearchive find _g`fcn'.ado
      if _rc {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
      }
    - else {
    - capture qui findfile _g`fcn'.ado
    = capture qui findfile _gcount.ado
    - if (`"`r(fn)'"' == "") {
    = if (`"/Applications/Stata/ado/base/_/_gcount.ado"' == "") {
      di as err in smcl "unknown {bf:egen} function {bf:`fcn'()}"
      exit 133
      }
    - }
    - if `"`par'"' != "(" {
    = if `"("' != "(" {
      exit 198
      }
    - if `"`args'"' == "_all" | `"`args'"' == "*" {
    = if `"id"' == "_all" | `"id"' == "*" {
      version 7.0, missing
      unab args : _all
      local args : subinstr local args "`_sortindex'" "", all word
      version 6.0, missing
      }
    - syntax [if] [in] [, *]
    - if _by() {
    - local byopt "by(`_byvars')"
    = local byopt "by(id)"
    - local cma ","
    - }
    - else if `"`options'"' != "" {
    = else if `""' != "" {
      local cma ","
      }
    - tempvar dummy
    - global EGEN_Varname `name'
    = global EGEN_Varname __00000Q
    - version 7.0, missing
    - global EGEN_SVarname `_sortindex'
    = global EGEN_SVarname __00000R
    - version 6.0, missing
    - if inlist("`fcn'","mode","concat","group") {
    = if inlist("count","mode","concat","group") {
      local vv : display "version " string(`cvers') ", missing:"
      }
    - capture noisily `vv' _g`fcn' `type' `dummy' = (`args') `if' `in' `cma' `byopt' `options'
    = capture noisily  _gcount float __00000S = (id)   , by(id) 
    - version 7.0, missing
    - local message $EGEN_Message
    = local message 1
    - version 6.0, missing
    - global EGEN_SVarname
    - global EGEN_Varname
    - global EGEN_Message
    - if _rc { exit _rc }
    - if "`message'" == "" {
    = if "1" == "" {
      quietly count if missing(`dummy')
      if r(N) {
      local s = cond(r(N)>1,"s","")
      local N : di %11.0fc r(N)
      local N `N'
      di in bl "(`N' missing value`s' generated)"
      }
      }
    - rename `dummy' `name'
    = rename __00000S __00000Q
    ----------------------------------------------------------------------------------------------------------------------------------------------------------------- end egen ---
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. 
. set tracedepth 2

. mata: mata set trace on
invalid syntax
r(198);

. mata: mata set tracedepth 2  // Shows 2 levels deep of function calls
invalid syntax
r(198);

. mata: mata set traceexpr on  
invalid syntax
r(198);

. mata set traceexpr on  
invalid expression
r(3000);

. mata: mata set trace on
invalid syntax
r(198);

. mata: set trace on
invalid expression
r(3000);

. help Mata
------------------------------------------------------------------------------------------------------------------------------------------------------------------- begin help ---
- version 9
- if "`c(console)'" == "console" || c(textresultsmode) != 0 {
= if "" == "console" || c(textresultsmode) != 0 {
  chelp `0'
  }
- else {
- whelp `0'
= whelp Mata
  ---------------------------------------------------------------------------------------------------------------------------------------------------------------- begin whelp ---
  - version 9
  - if "`c(console)'" == "console" | "$S_MODE"=="batch" {
  = if "" == "console" | ""=="batch" {
    chelp `0'
    }
  - else {
  - syntax [anything(everything)] [, noNew name(name) MARKer(name)]
  - if ("`new'" == "" | "`new'"=="new") & "`name'" == "" {
  = if ("" == "" | ""=="new") & "" == "" {
  - local name _new
  - }
  - if ("`new'" == "nonew") & "`name'" == "" {
  = if ("" == "nonew") & "_new" == "" {
    local name _nonew
    }
  - if "`name'`marker'" != "" {
  = if "_new" != "" {
  - if (strpos(`"`anything'"',"##")) {
  = if (strpos(`"Mata"',"##")) {
    local suffix "`marker'|`name'"
    }
  - else {
  - local suffix "##`marker'|`name'"
  = local suffix "##|_new"
  - }
  - }
  - if `"`anything'"' == "" {
  = if `"Mata"' == "" {
    view help help_advice`suffix'
    }
  - else {
  - view help `anything'`suffix'
  = view help Mata##|_new
  - }
  - }
  ------------------------------------------------------------------------------------------------------------------------------------------------------------------ end whelp ---
- }
--------------------------------------------------------------------------------------------------------------------------------------------------------------------- end help ---

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951197838.do

.   use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951389899.do

.    use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. mata
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
: list
                 <istmt>:  3499  list not found
r(3499);

: dir
                 <istmt>:  3499  dir not found
r(3499);

: mata describe

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,496   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
variable __00000Q not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
r(3500);

: tokens("-2,2 -1,1")
          1      2
    +---------------+
  1 |  -2,2   -1,1  |
    +---------------+

: l=tokens("-2,2 -1,1")

: l[0]
                 <istmt>:  3301  subscript invalid
r(3301);

: l[1]
  -2,2

: vectorToStripeDiag(m)
Input vector m dimensions: 1 x 20
[symmetric]
                  1             2             3             4             5             6             7             8             9            10            11            12
     +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
   1 |  1.011877834                                                                                                                                                          
   2 |  .9484398263   1.011877834                                                                                                                                            
   3 |  .9055616733   .9484398263   1.011877834                                                                                                                              
   4 |   .855208272   .9055616733   .9484398263   1.011877834                                                                                                                
   5 |   .814760195    .855208272   .9055616733   .9484398263   1.011877834                                                                                                  
   6 |  .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                                                                                    
   7 |  .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                                                                      
   8 |  .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                                                        
   9 |  .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                                          
  10 |  .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                            
  11 |  .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834              
  12 |  .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834
  13 |  .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263
  14 |  .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733
  15 |  .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195    .855208272
  16 |  .4639592463   .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577    .814760195
  17 |  .4424005259   .4639592463   .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379   .7717360577
  18 |  .4183625212   .4424005259   .4639592463   .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608   .7352168379
  19 |  .3991330244   .4183625212   .4424005259   .4639592463   .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656   .6935725608
  20 |  .3862719903   .3991330244   .4183625212   .4424005259   .4639592463   .4986636277   .5182143459   .5533703818   .5718195704   .6106043611   .6383361806   .6668603656
     +-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
                 13            14            15            16            17            18            19            20
      -----------------------------------------------------------------------------------------------------------------+
  13    1.011877834                                                                                                    |
  14    .9484398263   1.011877834                                                                                      |
  15    .9055616733   .9484398263   1.011877834                                                                        |
  16     .855208272   .9055616733   .9484398263   1.011877834                                                          |
  17     .814760195    .855208272   .9055616733   .9484398263   1.011877834                                            |
  18    .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                              |
  19    .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834                |
  20    .6935725608   .7352168379   .7717360577    .814760195    .855208272   .9055616733   .9484398263   1.011877834  |
      -----------------------------------------------------------------------------------------------------------------+

: list
                 <istmt>:  3499  list not found
r(3499);

: describe
                 <istmt>:  3499  describe not found
r(3499);

: mata describe

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,496   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
           24   string rowvector            l[2]
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

:  string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
',' found where '(' expected
r(3000);

:     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
',' found where '(' expected
r(3000);

:     
:     // Declare all variables upfront
expression invalid
r(3000);

:     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
',' found where '(' expected
r(3000);

:     real matrix Z, Z_hosp, Z_obs, Z_quasi
',' found where '(' expected
r(3000);

:     
:     nobs = st_nobs()

:     
:     // Get variable indices
expression invalid
r(3000);

:     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
',' found where '(' expected
r(3000);

:     hospitalid_var_ind = st_varindex(hospitalid_var)
                 <istmt>:  3499  hospitalid_var not found
r(3499);

:     time_var_ind = st_varindex(time_var)
                 <istmt>:  3499  time_var not found
r(3499);

:     hospobs_var_ind = st_varindex(hospobs_var)
                 <istmt>:  3499  hospobs_var not found
r(3499);

:     va_var_ind = st_varindex(va_var)
                 <istmt>:  3499  va_var not found
r(3499);

:     
:     // Create view of variables
expression invalid
r(3000);

:     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
                 <istmt>:  3499  hospitalid_var not found
r(3499);

:     
:     // Initialize
expression invalid
r(3000);

:     hospitalid = .

:     time = .

:     
: for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
'for' found where almost anything else expected
r(3000);

:         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
expression invalid
r(3000);

:             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
                 <istmt>:  3499  Z_hosp not found
r(3499);

:             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
                 <istmt>:  3499  Z_obs not found
r(3499);

:             
:             // Compute standard VA
expression invalid
r(3000);

:             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
                 <istmt>:  3499  Z_obs not found
r(3499);

:             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
'string' found where almost anything else expected
r(3000);

:                 string vector rules
nothing found where '(' expected
r(3000);

:                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
illegal arglist
r(3000);

:                 
:                 // Process each rule
expression invalid
r(3000);

:                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
'string' found where almost anything else expected
r(3000);

:                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
illegal arglist
r(3000);

:                     
:                     // Create selection vector
'vector' found where almost anything else expected
r(3000);

:                     real colvector selection
nothing found where '(' expected
r(3000);

:                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
                 <istmt>:  3499  Z_obs not found
r(3499);

:                     
:                     // Select rows meeting criteria
expression invalid
r(3000);

:                     Z_quasi = select(Z_obs, selection)
                 <istmt>:  3499  Z_obs not found
r(3499);

:                     
:                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
                 <istmt>:  3499  Z_quasi not found
r(3499);

:             }
expression invalid
r(3000);

:         }
expression invalid
r(3000);

:     }
expression invalid
r(3000);

: }
expression invalid
r(3000);

: mata des

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,496   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
            0   real matrix                 Z[0,0]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
            8   real scalar                 hospitalid
           24   string rowvector            l[2]
          160   real rowvector              m[20]
            8   real scalar                 nobs
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 time
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: clear
                 <istmt>:  3499  clear not found
r(3499);

: mata clear

: mata desc

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

: do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951692110.do
'do' found where almost anything else expected
r(3000);

: do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951715422.do
'do' found where almost anything else expected
r(3000);

: mata exit
unrecognized mata preprocessor command
r(199);

: exit
                 <istmt>:  3499  exit not found
r(3499);

: clear
                 <istmt>:  3499  clear not found
r(3499);

: q
                 <istmt>:  3499  q not found
r(3499);

: quit
                 <istmt>:  3499  quit not found
r(3499);

: mata:exit
                 <istmt>:  3499  exit not found
r(3499);

: mata exit
unrecognized mata preprocessor command
r(199);

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951766205.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize `rule', parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize `rule', parse(",")
  = tokenize -2,2, parse(",")
invalid 'parse' 
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(198);

end of do-file

r(198);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951862652.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectortostripediag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
                 <istmt>:  3499  vectortostripediag() not found
    }
    else {
    mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3499);

end of do-file

r(3499);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742951935622.do

.  mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectortostripediag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
                 <istmt>:  3499  vectortostripediag() not found
    }
    else {
    mata: driftcalclist(vectortostripediag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3499);

end of do-file

r(3499);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952051330.do

.   mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`mata_rules'"), tokens("`mata_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                tokens():  3204  matrix found where scalar required
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3204);

end of do-file

r(3204);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952233203.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // Convert to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     
.     // Pre-tokenize the strings
.     mata: {
270.         string vector rules, vars
271.         rules = tokens("`leaveout_years'")
272.         vars = tokens("`leaveout_vars'")
273.         driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", rules, vars)
274.     }
275. }
276. else {
277.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
278. }
279. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
280. if "`shrinkage_target'" != "" {
281.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
282. }
283. local leaveout_vars_to_keep 
284. if "`leaveout_years'" != "" {
285.     local leaveout_vars_to_keep  `leaveout_vars'
286. }
287. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
288. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
289.     if "`leaveout_vars'" != "" {
290.         foreach v in `leaveout_vars' {
291.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
292.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
293.         }
294.     }
295.     gen shrinktarget_base=`mshrinktarget'
296. }
297. 
. if (`firstloop'!=1) {
298.     append using `"`output'"', nolabel
299. }
300. qui save `"`output'"', replace
301. 
. * Turn firstloop counter off
. local firstloop=0
302. 
. 
. di "{txt}{hline}"
303. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
304.     restore, preserve
305.     keep `hospitalid' `year' `by' `output_addvars'
306.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
307.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
308. }
309. sort `hospitalid' `year' `by'
310. qui save `"`output'"', replace
311. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
312.     local bylabels=""
313.     forvalues i=1/`by_vals' {
314.         local bylabel : label `byvar' `i', strict
315.         local bylabel=subinstr("`bylabel'"," ","_",.)
316.         local bylabels `bylabels' _`bylabel'
317.     }
318.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
319. }
320. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
321. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
322. 
. 
. * Load the correct output dataset
. tokenize "`data'"
323. if inlist("`1'","preserve","merge") {
324.     restore
325. 
.     if (`merge_resid'==1) {
326.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
327.         else qui keep if missing(`hospitalid',`year',`class')
328.         forvalues l=1/`by_vals' {
329.             append using `"`resid_data_`l''"', nolabel
330.         }
331.     }
332.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
333.     /* else "`data'"=="preserve", and that is already loaded. */
. }
334. else {
335.     restore, not
336. 
.     if ("`data'"=="tv") use `"`output'"', clear
337.     /* else "`data'"=="variance", and that is already loaded. */
. }
338. 
. * Close log
. if (`nooutput'!=1) log close t
339. }
340. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | transmorphic vector leaveout_years, transmorphic vector leaveout_vars) {
>     
>     // Convert inputs to string vectors if they aren't already
>     string vector rules, vars
>     if (args()>7) {
>         // Handle either string scalar or string vector input
>         if (eltype(leaveout_years)=="string" && rows(leaveout_years)==1) {
>             rules = tokens(leaveout_years)
>         }
>         else {
>             rules = leaveout_years
>         }
>         
>         if (eltype(leaveout_vars)=="string" && rows(leaveout_vars)==1) {
>             vars = tokens(leaveout_vars)
>         }
>         else {
>             vars = leaveout_vars
>         }
>     }
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: {

unexpected end of line
<istmt> incomplete
    string vector rules, vars
    rules = tokens("`leaveout_years'")
    vars = tokens("`leaveout_vars'")
    driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", rules, vars)
    }
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3000);

end of do-file

r(3000);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952508350.do

.   mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     local n_rules = wordcount("`leaveout_years'")
 22.     
.     mata
 23.         string vector rules, vars
 24.         rules = tokens("`leaveout_years'")
 25.         vars = tokens("`leaveout_vars'")
 26.         driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", rules, vars)
 27.     end

. }
} is not a valid command name
r(199);

end of do-file
r(199);

end of do-file

r(199);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952515428.do

.   mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     local n_rules = wordcount("`leaveout_years'")
 22.     
.     mata
 23.         string vector rules, vars
 24.         rules = tokens("`leaveout_years'")
 25.         vars = tokens("`leaveout_vars'")
 26.         driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", rules, vars)
 27.     end

. }
} is not a valid command name
r(199);

end of do-file
r(199);

end of do-file

r(199);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952575992.do

.   mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     local n_rules = wordcount("`leaveout_years'")
 22.     
.     mata
 23.         string vector rules, vars
 24.         rules = tokens("`leaveout_years'")
 25.         vars = tokens("`leaveout_vars'")
 26.         driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", rules, vars)
 27.     end

. }
} is not a valid command name
r(199);

end of do-file
r(199);

end of do-file

r(199);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742952845694.do

.     mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`leaveout_years'"), tokens("`leaveout_vars'"))
269. }
270. else {
271.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", tokens("`leaveout_years'"), tokens("`leaveout_vars'"))
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", tokens("-2,2 -1,1"), tokens("tv_2yr tv_1yr"))
Input vector m dimensions: 1 x 20
                tokens():  3204  matrix found where scalar required
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3204);

end of do-file

r(3204);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742953082644.do

.     mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[2]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
         driftcalclist():  3301  subscript invalid
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3301);

end of do-file

r(3301);

. mata 
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
: mata des

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,352   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: leaveout_years='-2,2 -1,1'
nothing found where subexp expected
r(3000);

: leaveout_years="-2,2 -1,1"

:   string vector rules
nothing found where '(' expected
r(3000);

: 
:             
:            
: string vector rules
nothing found where '(' expected
r(3000);

: (
> )
nothing found where subexp expected
r(3000);

: (string vector rules)
'string' found where almost anything else expected
r(3000);

: rules = tokens(leaveout_years)

:  _parse_rule(rules[i], before, after)
                 <istmt>:  3499  i not found
r(3499);

:  _parse_rule(rules[1], before, after)
                 <istmt>:  3499  before not found
r(3499);

: string scalar before, after
',' found where '(' expected
r(3000);

: before=""

: after=""

: string scalar before, after
',' found where '(' expected
r(3000);

:  _parse_rule(rules[1], before, after)

: mata des

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,352   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
            9   string scalar               after
           10   string scalar               before
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
           17   string scalar               leaveout_years
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
           24   string rowvector            rules[2]
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: before
  -2

: after
  ,

: parts
                 <istmt>:  3499  parts not found
r(3499);

:  rule=token(rules[1],",")
                 <istmt>:  3499  token() not found
r(3499);

:  rule=tokens(rules[1],",")

: rule
        1    2    3
    +----------------+
  1 |  -2    ,    2  |
    +----------------+

: do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742953420756.do
'do' found where almost anything else expected
r(3000);

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742953459208.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
variable tv_2yr tv_1yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3500);

end of do-file

r(3500);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742953709589.do

.     mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
> 
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(var_names[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3500);

end of do-file

r(3500);

. mata 
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
: mata des

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,400   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742953968981.do
'do' found where almost anything else expected
r(3000);

: 
: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742954447154.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
> 
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>                     di "var_names[i]: " var_names[i]
invalid expression
(19 lines skipped)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
r(3000);

end of do-file
r(3000);

end of do-file

r(3000);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742954495156.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
> 
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>          
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(var_names[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3500);

end of do-file

r(3500);

. drop tv_*

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742954555125.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.     // convert leaveout rules and vars to mata format
.     local n_rules = wordcount("`leaveout_years'")
269.     mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
270.     mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
271.     
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
272. }
273. else {
274.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
275. }
276. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
277. if "`shrinkage_target'" != "" {
278.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
279. }
280. local leaveout_vars_to_keep 
281. if "`leaveout_years'" != "" {
282.     local leaveout_vars_to_keep  `leaveout_vars'
283. }
284. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
285. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
286.     if "`leaveout_vars'" != "" {
287.         foreach v in `leaveout_vars' {
288.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
289.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
290.         }
291.     }
292.     gen shrinktarget_base=`mshrinktarget'
293. }
294. 
. if (`firstloop'!=1) {
295.     append using `"`output'"', nolabel
296. }
297. qui save `"`output'"', replace
298. 
. * Turn firstloop counter off
. local firstloop=0
299. 
. 
. di "{txt}{hline}"
300. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
301.     restore, preserve
302.     keep `hospitalid' `year' `by' `output_addvars'
303.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
304.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
305. }
306. sort `hospitalid' `year' `by'
307. qui save `"`output'"', replace
308. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
309.     local bylabels=""
310.     forvalues i=1/`by_vals' {
311.         local bylabel : label `byvar' `i', strict
312.         local bylabel=subinstr("`bylabel'"," ","_",.)
313.         local bylabels `bylabels' _`bylabel'
314.     }
315.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
316. }
317. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
318. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
319. 
. 
. * Load the correct output dataset
. tokenize "`data'"
320. if inlist("`1'","preserve","merge") {
321.     restore
322. 
.     if (`merge_resid'==1) {
323.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
324.         else qui keep if missing(`hospitalid',`year',`class')
325.         forvalues l=1/`by_vals' {
326.             append using `"`resid_data_`l''"', nolabel
327.         }
328.     }
329.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
330.     /* else "`data'"=="preserve", and that is already loaded. */
. }
331. else {
332.     restore, not
333. 
.     if ("`data'"=="tv") use `"`output'"', clear
334.     /* else "`data'"=="variance", and that is already loaded. */
. }
335. 
. * Close log
. if (`nooutput'!=1) log close t
336. }
337. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
> 
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>          
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(var_names[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = wordcount("`leaveout_years'")
  = local n_rules = wordcount("-2,2 -1,1")
  - mata: st_local("mata_rules", invtokens(tokens("`leaveout_years'")))
  = mata: st_local("mata_rules", invtokens(tokens("-2,2 -1,1")))
  - mata: st_local("mata_vars", invtokens(tokens("`leaveout_vars'")))
  = mata: st_local("mata_vars", invtokens(tokens("tv_2yr tv_1yr")))
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3500);

end of do-file

r(3500);

. mata
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
: t=tokens("tv_2yr tv_1yr")

: t[1]
  tv_2yr

: t[2]
  tv_1yr

: do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742954856946.do
'do' found where almost anything else expected
r(3000);

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742954863829.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.    
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
> 
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>          
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(var_names[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                      Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -2,2 -1,1 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "1"
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_2yr tv_1yr
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/2 {
  - local var_`i' "``i''"
  = local var_1 "tv_2yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_2yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_2yr = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_1yr"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_1yr, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_1yr = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y 

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    reg score_r1 `shrinkage_target'
    qui predict score_r if e(sample), res
    qui predict y_shrinktarget if e(sample), xb
    capture confirm variable y_shrinktarget
    if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
    }
  - else {
  - gen score_r = score_r1
  - }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
    }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "" != "" {
    collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - else {
  - collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.1969038 0 5.0986205 1.0059214
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-2,2 -1,1"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-2,2 -1,1", "tv_2yr tv_1yr")
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3500);

end of do-file

r(3500);

. sum tv_2yr

    Variable |        Obs        Mean    Std. dev.       Min        Max
-------------+---------------------------------------------------------
      tv_2yr |          0

. desc tv*
------------------------------------------------------------------------------------------------------------------------------------------------------------------- begin desc ---
- local version : di "version " string(_caller()) ":"
- `version' describe `0'
= version 18.5: describe tv*
  ------------------------------------------------------------------------------------------------------------------------------------------------------------- begin describe ---
  - version 9
  - local version : di "version " string(_caller()) ":"
  - syntax [anything] [using] [, SImple REPLACE *]
  - if ("`replace'"!="") {
  = if (""!="") {
    describe_mk `0'
    return add
    exit
    }
  - local varlist `"`anything'"'
  = local varlist `"tv*"'
  - if ("`simple'" == "") {
  = if ("" == "") {
  - `version' _describe `0'
  = version 18.5: _describe tv*

Variable      Storage   Display    Value
    name         type    format    label      Variable label
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
tv_2yr          float   %9.0g                 
tv_1yr          float   %9.0g                 
  - return add
  - }
  - else {
    if (`"`options'"' != "") {
    di as err "simple may not be combined with other options"
    exit 198
    }
    if (`"`using'"' != "") {
    qui `version' describe `varlist' `using', varlist
    if "`varlist'" == "" {
    local vars "`r(varlist)'"
    }
    else {
    local vars "`varlist'"
    }
    local wid = 2
    local n : list sizeof vars
    if `n'==0 {
    exit
    }
    if "`c(hasicu)'" == "1" {
    foreach x of local vars {
    local wid = max(`wid', udstrlen(`"`x'"'))
    }
    }
    else {
    foreach x of local vars {
    local wid = max(`wid', strlen(`"`x'"'))
    }
    }
    local wid = `wid' + 2
    local cols = int((`c(linesize)'+1)/`wid')
    if `cols' < 2 {
    foreach x of local `vars' {
    di as txt `col' `"`x'"'
    }
    exit
    }
    local lines = `n'/`cols'
    local lines = int(cond(`lines'>int(`lines'), `lines'+1, `lines'))
    forvalues i=1(1)`lines' {
    local top = min((`cols')*`lines'+`i', `n')
    local col = 1
    forvalues j=`i'(`lines')`top' {
    local x : word `j' of `vars'
    di as txt _column(`col') "`x'" _c
    local col = `col' + `wid'
    }
    di as txt
    }
    qui `version' describe `varlist' `using', short
    return add
    }
    else {
    ds `varlist'
    qui `version' _describe `varlist', short
    return add
    }
    }
  --------------------------------------------------------------------------------------------------------------------------------------------------------------- end describe ---
--------------------------------------------------------------------------------------------------------------------------------------------------------------------- end desc ---

. set trace off

. desc tv*

Variable      Storage   Display    Value
    name         type    format    label      Variable label
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
tv_2yr          float   %9.0g                 
tv_1yr          float   %9.0g                 

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955137703.do

.    mata: mata clear

.  do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268.    
.     // call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M = J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i] = m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return(M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Note: Changed string vector to string scalar for the optional parameters
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>    
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 // Split the full leaveout_years string into individual rules
>                 string vector rules
>                 rules = tokens(leaveout_years)  // "-2,2 -1,1" becomes ("-2,2", "-1,1")
>                 
>                 string vector var_names
>                 var_names = tokens(leaveout_vars)  // Splits to ("tv_2yr", "tv_1yr")
>             
>                 // Process each rule
>                 for (i=1; i<=length(rules); i++) {
>                     string scalar before, after
>                     _parse_rule(rules[i], before, after)  // Pass single rule like "-2,2"
>                     
>                     // Create selection vector
>                     real colvector selection
>                     selection = (Z_obs[.,2] :< (time + strtoreal(before))) :| 
>                                (Z_obs[.,2] :> (time + strtoreal(after)))
>                     
>                     // Select rows meeting criteria
>                     Z_quasi = select(Z_obs, selection)
>          
>                     if (rows(Z_quasi) > 0) {
>                         real scalar var_index
>                         var_index = st_varindex(var_names[i])
>                         if (var_index >= 0) {
>                             st_store(obs, var_index,
>                                 driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, 
>                                          Z_quasi[.,3], Z_quasi[.,4]))
>                         }
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     // Input: rule = "-2,2"
>     string vector parts
>     parts = tokens(rule, ",")  // Split at comma: ("-2", "2")
>     before = parts[1]          // before = "-2"
>     after = parts[3]           // after = "2"
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.     use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
run regressions residualizing dependent variable for controls

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
Standard deviations: total, classes, students, Hospital same year
5.1969038 0 5.0986205 1.0059214
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
Covariances used for VA computations:
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
r(3500);

end of do-file

r(3500);

. mata
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
: mata des

      # bytes   type                        name and extent
-------------------------------------------------------------------------------
          232   void                        _parse_rule()
          176   void                        check_m_nomissing()
        1,612   real matrix                 compute_cov_corr()
        1,232   real rowvector              computeweights()
          720   real rowvector              create_m()
          260   real scalar                 driftcalc()
        2,448   void                        driftcalclist()
          400   real matrix                 rightAppendMatrices()
        1,556   void                        saveVariancesToDataset()
          496   real matrix                 vectorToStripeDiag()
          608   real matrix                 CC[19,4]
          152   real colvector              corr_lag_accum[19]
            8   real scalar                 corr_sameyear_accum
          152   real colvector              cov_lag_accum[19]
            8   real scalar                 cov_sameyear_accum
          152   real colvector              cov_se_lag_accum[19]
          160   real rowvector              m[20]
          152   real colvector              obs_lag_accum[19]
            8   real scalar                 obs_sameyear_accum
            8   real scalar                 var_class_accum
            8   real scalar                 var_ind_accum
            8   real scalar                 var_total_accum
-------------------------------------------------------------------------------

: tv_2yr=.

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955191639.do

.   use test.dta, clear

.     hospital_ebayes y, hospitalid(id) year(year) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr") data("merge tv")
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
run regressions residualizing dependent variable for controls

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(0, 3999999)   =      0.00
       Model |           0         0           .   Prob > F        =         .
    Residual |   108031210 3,999,999  27.0078093   R-squared       =    0.0000
-------------+----------------------------------   Adj R-squared   =    0.0000
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.1969

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
       _cons |   .0281648   .0025985    10.84   0.000      .023072    .0332577
------------------------------------------------------------------------------
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.01187783
Standard deviations: total, classes, students, Hospital same year
5.1969038 0 5.0986205 1.0059214
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
                  1             2             3
     +-------------------------------------------+
   1 |  .9484398263   .6187279235         76000  |
   2 |  .9055616733   .5909141971         72000  |
   3 |   .855208272   .5585553363         68000  |
   4 |   .814760195   .5329328703         64000  |
   5 |  .7717360577   .5049087119         60000  |
   6 |  .7352168379   .4813707094         56000  |
   7 |  .6935725608   .4537533003         52000  |
   8 |  .6668603656   .4358123596         48000  |
   9 |  .6383361806   .4171399845         44000  |
  10 |  .6106043611    .398616754         40000  |
  11 |  .5718195704   .3728344699         36000  |
  12 |  .5533703818   .3606639891         32000  |
  13 |  .5182143459   .3369557927         28000  |
  14 |  .4986636277   .3233357491         24000  |
  15 |  .4639592463   .3009108985         20000  |
  16 |  .4424005259    .286561166         16000  |
  17 |  .4183625212   .2723878883         12000  |
  18 |  .3991330244   .2615622305          8000  |
  19 |  .3862719903    .255549152          4000  |
     +-------------------------------------------+
Covariances used for VA computations:
                  1
     +---------------+
   1 |  .9484398263  |
   2 |  .9055616733  |
   3 |   .855208272  |
   4 |   .814760195  |
   5 |  .7717360577  |
   6 |  .7352168379  |
   7 |  .6935725608  |
   8 |  .6668603656  |
   9 |  .6383361806  |
  10 |  .6106043611  |
  11 |  .5718195704  |
  12 |  .5533703818  |
  13 |  .5182143459  |
  14 |  .4986636277  |
  15 |  .4639592463  |
  16 |  .4424005259  |
  17 |  .4183625212  |
  18 |  .3991330244  |
  19 |  .3862719903  |
     +---------------+
Input vector m dimensions: 1 x 20
variable tv_2yr not found
           st_varindex():  3500  invalid Stata variable name
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
r(3500);

end of do-file

r(3500);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955581012.do

.  mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize `rule', parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(leaveout_years[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[2]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
invalid 'parse' 
r(198);

end of do-file

r(198);

. set trace on

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955594959.do

.  mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize `rule', parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(leaveout_years[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[2]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize `rule', parse(",")
  = tokenize -1,+1, parse(",")
invalid 'parse' 
    local rule_`n_rules'_before "`1'"
    local rule_`n_rules'_after "`3'"
    }
    tokenize `leaveout_vars'
    forvalues i = 1/`n_rules' {
    local var_`i' "``i''"
    capture confirm variable ``i'', exact
    if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
    qui gen float ``i'' = .
    }
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(198);

end of do-file

r(198);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955650339.do

.    mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string vector leaveout_years, string vector leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(leaveout_years[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(leaveout_vars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[2]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_3_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_3_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_4_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_4_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-5,", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_5_before "-5"
  - local rule_`n_rules'_after "`3'"
  = local rule_5_after ""
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize ",+5", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_6_before ","
  - local rule_`n_rules'_after "`3'"
  = local rule_6_after ""
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/6 {
  - local var_`i' "``i''"
  = local var_1 "tv_tm1_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm1_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm1_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_tm2_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm2_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm2_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_3 "tv_tm3_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_4 "tv_tm3_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_5 "tv_tm5_t"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm5_t, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm5_t = .
  - }
  - local var_`i' "``i''"
  = local var_6 "tv_t_t5"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_t_t5, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_t_t5 = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1426.22
       Model |  37072.7593         1  37072.7593   Prob > F        =    0.0000
    Residual |   103974720 3,999,998   25.993693   R-squared       =    0.0004
-------------+----------------------------------   Adj R-squared   =    0.0004
       Total |   104011793 3,999,999  26.0029547   Root MSE        =    5.0984

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9604015   .0254308    37.77   0.000     .9105581    1.010245
       _cons |  -.0000164   .0025492    -0.01   0.995    -.0050127    .0049799
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00053839
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.098401 0 4.9993154 1.0002692
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9476917857   .6312018312         76000  |
   2 |  .9044250969    .602734024         72000  |
   3 |  .8527268125   .5689088551         68000  |
   4 |  .8125903186   .5429125543         64000  |
   5 |  .7695101294    .514201128         60000  |
   6 |  .7336665729   .4905786896         56000  |
   7 |  .6927342957   .4628665781         52000  |
   8 |   .666811696   .4449626476         48000  |
   9 |  .6377754865   .4254554887         44000  |
  10 |  .6084897402   .4055486704         40000  |
  11 |  .5701441751   .3795639897         36000  |
  12 |  .5496269473   .3656412528         32000  |
  13 |  .5171823385   .3430774965         28000  |
  14 |  .4989734741   .3300388215         24000  |
  15 |  .4624820673    .305849515         20000  |
  16 |  .4413674262   .2912868009         16000  |
  17 |  .4185891693   .2773554005         12000  |
  18 |  .3995607205   .2664730047          8000  |
  19 |  .3838734619    .259079548          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9476917857  |
   2 |  .9044250969  |
   3 |  .8527268125  |
   4 |  .8125903186  |
   5 |  .7695101294  |
   6 |  .7336665729  |
   7 |  .6927342957  |
   8 |   .666811696  |
   9 |  .6377754865  |
  10 |  .6084897402  |
  11 |  .5701441751  |
  12 |  .5496269473  |
  13 |  .5171823385  |
  14 |  .4989734741  |
  15 |  .4624820673  |
  16 |  .4413674262  |
  17 |  .4185891693  |
  18 |  .3995607205  |
  19 |  .3838734619  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5", "tv_tm1_t1             tv_tm2_t2        
>      tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5")
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955650339.do

.    mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
variable lyears undeclared
variable lvars undeclared
(8 lines skipped)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
r(3000);

end of do-file
r(3000);

end of do-file

r(3000);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955650339.do

.    mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[3]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_3_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_3_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_4_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_4_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-5,", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_5_before "-5"
  - local rule_`n_rules'_after "`3'"
  = local rule_5_after ""
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize ",+5", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_6_before ","
  - local rule_`n_rules'_after "`3'"
  = local rule_6_after ""
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/6 {
  - local var_`i' "``i''"
  = local var_1 "tv_tm1_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm1_t1, exact
  - if (_rc==0) {
  - di as error "The dataset loaded in memory cannot have a variable named ``i''."
  = di as error "The dataset loaded in memory cannot have a variable named tv_tm1_t1."
The dataset loaded in memory cannot have a variable named tv_tm1_t1.
  - exit 110
    }
    qui gen float ``i'' = .
    }
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(110);

end of do-file

r(110);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955882682.do

.  use test.dta, clear

.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[3]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

. 
.         hospital_ebayes y, hospitalid(hospid) year(year) data("merge tv") ///
>             controls(x) absorb(hospid) shrinkage_target(lnvol)
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
variable hospid not found
(error in option hospitalid())
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(111);

end of do-file

r(111);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Build selection condition
>                     string scalar condition
>                     condition = ""
>                     if (before != "") condition = condition + "(Z_obs[.,2]:<time" + before + ")"
>                     if (after != "") {
>                         if (condition != "") condition = condition + "+"
>                         condition = condition + "(Z_obs[.,2]:>time" + after + ")"
>                     }
>                     
>                     // Apply selection and compute VA
>                     Z_quasi = select(Z_obs, strtoreal(condition))
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[3]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_3_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_3_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_4_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_4_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-5,", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_5_before "-5"
  - local rule_`n_rules'_after "`3'"
  = local rule_5_after ""
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize ",+5", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_6_before ","
  - local rule_`n_rules'_after "`3'"
  = local rule_6_after ""
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/6 {
  - local var_`i' "``i''"
  = local var_1 "tv_tm1_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm1_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm1_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_tm2_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm2_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm2_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_3 "tv_tm3_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_4 "tv_tm3_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_5 "tv_tm5_t"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm5_t, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm5_t = .
  - }
  - local var_`i' "``i''"
  = local var_6 "tv_t_t5"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_t_t5, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_t_t5 = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1426.22
       Model |  37072.7593         1  37072.7593   Prob > F        =    0.0000
    Residual |   103974720 3,999,998   25.993693   R-squared       =    0.0004
-------------+----------------------------------   Adj R-squared   =    0.0004
       Total |   104011793 3,999,999  26.0029547   Root MSE        =    5.0984

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9604015   .0254308    37.77   0.000     .9105581    1.010245
       _cons |  -.0000164   .0025492    -0.01   0.995    -.0050127    .0049799
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00053839
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.098401 0 4.9993154 1.0002692
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9476917857   .6312018312         76000  |
   2 |  .9044250969    .602734024         72000  |
   3 |  .8527268125   .5689088551         68000  |
   4 |  .8125903186   .5429125543         64000  |
   5 |  .7695101294    .514201128         60000  |
   6 |  .7336665729   .4905786896         56000  |
   7 |  .6927342957   .4628665781         52000  |
   8 |   .666811696   .4449626476         48000  |
   9 |  .6377754865   .4254554887         44000  |
  10 |  .6084897402   .4055486704         40000  |
  11 |  .5701441751   .3795639897         36000  |
  12 |  .5496269473   .3656412528         32000  |
  13 |  .5171823385   .3430774965         28000  |
  14 |  .4989734741   .3300388215         24000  |
  15 |  .4624820673    .305849515         20000  |
  16 |  .4413674262   .2912868009         16000  |
  17 |  .4185891693   .2773554005         12000  |
  18 |  .3995607205   .2664730047          8000  |
  19 |  .3838734619    .259079548          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9476917857  |
   2 |  .9044250969  |
   3 |  .8527268125  |
   4 |  .8125903186  |
   5 |  .7695101294  |
   6 |  .7336665729  |
   7 |  .6927342957  |
   8 |   .666811696  |
   9 |  .6377754865  |
  10 |  .6084897402  |
  11 |  .5701441751  |
  12 |  .5496269473  |
  13 |  .5171823385  |
  14 |  .4989734741  |
  15 |  .4624820673  |
  16 |  .4413674262  |
  17 |  .4185891693  |
  18 |  .3995607205  |
  19 |  .3838734619  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5", "tv_tm1_t1             tv_tm2_t2        
>      tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5")
Input vector m dimensions: 1 x 20
                select():  3200  conformability error
         driftcalclist():     -  function returned error
                 <istmt>:     -  function returned error
    }
    else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
    local shrinkage_vars_to_keep
    if "`shrinkage_target'" != "" {
    local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
    }
    local leaveout_vars_to_keep
    if "`leaveout_years'" != "" {
    local leaveout_vars_to_keep `leaveout_vars'
    }
    keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(3200);

end of do-file

r(3200);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(lyears); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Get base observations
>                     real matrix Z_quasi
symbol Z_quasi multiply defined
(44 lines skipped)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
r(3000);

end of do-file
r(3000);

end of do-file

r(3000);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Get base observations
>                     real matrix Z_quasi
symbol Z_quasi multiply defined
(27 lines skipped)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
r(3000);

end of do-file
r(3000);

end of do-file

r(3000);

. set trace on

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Get base observations
>                     real matrix Z_quasi
symbol Z_quasi multiply defined
(27 lines skipped)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
r(3000);

end of do-file
r(3000);

end of do-file

r(3000);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep  `shrinkage_target' `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Get base observations
>         
>                     Z_quasi = Z_obs
>                     
>                     // Apply filters if valid
>                     if (before != "" & before != " ") {
>                         Z_quasi = select(Z_quasi, Z_quasi[.,2] :< (time + strtoreal(before)))
>                     }
>                     if (after != "" & after != " ") {
>                         Z_quasi = select(Z_quasi, Z_quasi[.,2] :> (time + strtoreal(after)))
>                     }
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[3]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_3_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_3_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_4_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_4_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-5,", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_5_before "-5"
  - local rule_`n_rules'_after "`3'"
  = local rule_5_after ""
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize ",+5", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_6_before ","
  - local rule_`n_rules'_after "`3'"
  = local rule_6_after ""
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/6 {
  - local var_`i' "``i''"
  = local var_1 "tv_tm1_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm1_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm1_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_tm2_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm2_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm2_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_3 "tv_tm3_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_4 "tv_tm3_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_5 "tv_tm5_t"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm5_t, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm5_t = .
  - }
  - local var_`i' "``i''"
  = local var_6 "tv_t_t5"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_t_t5, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_t_t5 = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1426.22
       Model |  37072.7593         1  37072.7593   Prob > F        =    0.0000
    Residual |   103974720 3,999,998   25.993693   R-squared       =    0.0004
-------------+----------------------------------   Adj R-squared   =    0.0004
       Total |   104011793 3,999,999  26.0029547   Root MSE        =    5.0984

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9604015   .0254308    37.77   0.000     .9105581    1.010245
       _cons |  -.0000164   .0025492    -0.01   0.995    -.0050127    .0049799
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00053839
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.098401 0 4.9993154 1.0002692
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9476917857   .6312018312         76000  |
   2 |  .9044250969    .602734024         72000  |
   3 |  .8527268125   .5689088551         68000  |
   4 |  .8125903186   .5429125543         64000  |
   5 |  .7695101294    .514201128         60000  |
   6 |  .7336665729   .4905786896         56000  |
   7 |  .6927342957   .4628665781         52000  |
   8 |   .666811696   .4449626476         48000  |
   9 |  .6377754865   .4254554887         44000  |
  10 |  .6084897402   .4055486704         40000  |
  11 |  .5701441751   .3795639897         36000  |
  12 |  .5496269473   .3656412528         32000  |
  13 |  .5171823385   .3430774965         28000  |
  14 |  .4989734741   .3300388215         24000  |
  15 |  .4624820673    .305849515         20000  |
  16 |  .4413674262   .2912868009         16000  |
  17 |  .4185891693   .2773554005         12000  |
  18 |  .3995607205   .2664730047          8000  |
  19 |  .3838734619    .259079548          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9476917857  |
   2 |  .9044250969  |
   3 |  .8527268125  |
   4 |  .8125903186  |
   5 |  .7695101294  |
   6 |  .7336665729  |
   7 |  .6927342957  |
   8 |   .666811696  |
   9 |  .6377754865  |
  10 |  .6084897402  |
  11 |  .5701441751  |
  12 |  .5496269473  |
  13 |  .5171823385  |
  14 |  .4989734741  |
  15 |  .4624820673  |
  16 |  .4413674262  |
  17 |  .4185891693  |
  18 |  .3995607205  |
  19 |  .3838734619  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5", "tv_tm1_t1             tv_tm2_t2        
>      tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5")
Input vector m dimensions: 1 x 20
  - }
  - else {
    mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
    }
  - local shrinkage_vars_to_keep
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - local shrinkage_vars_to_keep `shrinkage_target' `mshrinktarget'
  = local shrinkage_vars_to_keep z __000006
  - }
  - local leaveout_vars_to_keep
  - if "`leaveout_years'" != "" {
  = if "-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5" != "" {
  - local leaveout_vars_to_keep `leaveout_vars'
  = local leaveout_vars_to_keep tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - }
  - keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
  = keep id year  tv z __000006 tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
variable z not found
    if "`shrinkage_target'" != "" {
    if "`leaveout_vars'" != "" {
    foreach v in `leaveout_vars' {
    gen `v'_shrinktgt = `v' + `mshrinktarget'
    replace `v'_shrinktgt=`mshrinktarget' if `v'==.
    }
    }
    gen shrinktarget_base=`mshrinktarget'
    }
    if (`firstloop'!=1) {
    append using `"`output'"', nolabel
    }
    qui save `"`output'"', replace
    local firstloop=0
    di "{txt}{hline}"
    if "`output_addvars'"!="" quietly {
    restore, preserve
    keep `hospitalid' `year' `by' `output_addvars'
    bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
    merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
    }
    sort `hospitalid' `year' `by'
    qui save `"`output'"', replace
    if ("`by'"!="") {
    local bylabels=""
    forvalues i=1/`by_vals' {
    local bylabel : label `byvar' `i', strict
    local bylabel=subinstr("`bylabel'"," ","_",.)
    local bylabels `bylabels' _`bylabel'
    }
    mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sameyear
> _accum, obs_sameyear_accum, tokens(st_local("bylabels")))
    }
    else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, "")
    if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
    tokenize "`data'"
    if inlist("`1'","preserve","merge") {
    restore
    if (`merge_resid'==1) {
    if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
    else qui keep if missing(`hospitalid',`year',`class')
    forvalues l=1/`by_vals' {
    append using `"`resid_data_`l''"', nolabel
    }
    }
    if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
    }
    else {
    restore, not
    if ("`data'"=="tv") use `"`output'"', clear
    }
    if (`nooutput'!=1) log close t
    }
  -------------------------------------------------------------------------------------------------------------------------------------------------------- end hospital_ebayes ---
r(111);

end of do-file

r(111);

. do /var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T/StataRun1742955913220.do

. use test.dta, clear

.  
.         mata: mata clear

.         do ../src/hospital_ebayes.ado

. *! version 0.0.1  February 2019 Maurice Dalton, daltonm
. /* Based on original code written by Michael Stepner, forked */
. 
. /*******************************************************************************
> Hospital Value-Added Model with Leave-Out Estimators
> --------------------------------------------------------------------------------
> 
> This program estimates hospital value-added models using various leave-out 
> estimators. It adapts teacher value-added methods for hospital settings with 
> several key modifications:
> 
> 1. Allows users to controls for hospital volume effects
> 2. Handles hospital-specific structure, note we impose one "classroom" per hospital-year
> 3. Provides additional leave-out estimators and intermediate outputs
> 4. Includes hospital-specific adjustments
> 
> Required Arguments:
> - depvar:       Dependent variable (outcome measure)
> - hospitalid:   Hospital identifier
> - year:         Year identifier
> 
> Optional Arguments:
> - class:         Ward/unit identifier - leftover from original code but not used. We set this 
>                  to 1 for all observations, so there is one class per hospital-year
> - by:          Estimate separately by groups
> - controls:    Additional control variables
> - shrinkage_target: Variables to control for before shrinkage estimation
> - absorb:      Fixed effects to absorb
> - tfx_resid:   Hospital fixed effects residuals
> - data:        Data handling options ("preserve", "tv", "merge tv", etc.)
> - output:      Output file path prefix
> - driftlimit:  Maximum number of lags (-1 for all)
> - leaveout_years: New parameter for year ranges to leave out
> - leaveout_vars: New parameter for variable mappings
> 
> Usage Example:
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume)
> 
>     // Example with leave-out estimation
>     vamhclose score, hospitalid(hospital) year(year) ///
>         controls(age female) shrinkage_target(volume) ///
>         leaveout_years("-2,2 -1,1") leaveout_vars("tv_2yr tv_1yr")
>         
>     /* The leaveout example above will:
>     1. Create tv_2yr using data excluding 2 years before/after current year
>     2. Create tv_1yr using data excluding 1 year before/after current year
>     Format is "before,after" where negative numbers are years before */
> 
> Notes:
> - Requires Stata 10.2+
> - Missing values in key variables are automatically dropped
> - Hospital IDs should be consistent across years
> 
> Authors:
> Maurice Dalton 
> Doug Staiger 
> ---
> Based on vam.ado written by Michael Stepner version 2.0.1  27jul2013.
> *******************************************************************************/
. 
. 
. cap program drop  hospital_ebayes

. program define hospital_ebayes
  1. version 10.2
  2. 
. set more off
  3. syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) ///
>     by(varlist) ///
>     shrinkage_target(varlist) ///
>     controls(varlist ts fv) absorb(varname) tfx_resid(varname) ///
>     data(string) output(string) output_addvars(varlist) ///
>     driftlimit(integer -1) ///
>     leaveout_years(string) /// New parameter for year ranges to leave out
>     leaveout_vars(string)]  /// New parameter for variable mappings
> 
  4. * By default we use 1 class or ward per hospital. We didnt feel there was 
. * a direct comparable unit to classrooms within a hospital.
. if "`class'" == "" {
  5.     tempvar class_var 
  6.     egen `class_var'=group(`hospitalid' `year')
  7.     local class `class_var' 
  8. }
  9. 
. * Error checks
. local depvar `varlist'
 10. 
. capture confirm variable score_r, exact
 11. if (_rc==0) {
 12.     di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
 13.     exit 110
 14. }
 15. 
. capture confirm variable tv, exact
 16. if (_rc==0) {
 17.     di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
 18.     exit 110
 19. }
 20. 
. 
. if ("`leaveout_years'"!="") {
 21.     // Parse the leaveout rules
.     local n_rules = 0
 22.     foreach rule in `leaveout_years' {
 23.         local ++n_rules
 24.         tokenize "`rule'", parse(",")
 25.         local rule_`n_rules'_before "`1'"
 26.         local rule_`n_rules'_after "`3'"
 27.     }
 28.     
.     // Parse variable names
.     tokenize `leaveout_vars'
 29.     forvalues i = 1/`n_rules' {
 30.         local var_`i' "``i''"
 31.         capture confirm variable ``i'', exact
 32.         if (_rc==0) {
 33.             di as error "The dataset loaded in memory cannot have a variable named ``i''."
 34.             exit 110
 35.         }
 36.         qui gen float ``i'' = .
 37.     }
 38. }
 39. 
. local merge_tv=0
 40. local merge_resid=0
 41. if ("`data'"=="") local data="preserve"
 42. else {
 43.     if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
 44.         di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
 45.         exit 198
 46.     }
 47.     else {
 48.         tokenize "`data'"
 49.         if ("`1'")=="merge" {
 50.             if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
 51.             if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
 52.         }
 53.     }
 54. }
 55. 
. if "`tfx_resid'"!="" & "`absorb'"!="" {
 56.     di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
 57.     exit 198
 58. }
 59. 
. * If output was left blank, set a tempfile for the tv output
. if `"`output'"'=="" {
 60.     tempfile output
 61.     local nooutput=1
 62. }
 63. else local nooutput=0
 64. 
. * Start log
. if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
 65. 
. * Process by variables
. if ("`by'"!="") {
 66.     tempvar byvar
 67.     egen `byvar'=group(`by'), label
 68.     sum `byvar', meanonly
 69.     local by_vals=`r(max)'
 70. }
 71. else local by_vals=1
 72. 
. ****************
. 
. preserve
 73. 
. *** Run through separately for each by-value.
. local firstloop=1
 74. forvalues l=1/`by_vals' {
 75. 
.     if (`firstloop'!=1) restore, preserve
 76. 
.     *** Print heading (with by-variable identifier if applciable)
.     di "{txt}{hline}"
 77.     if ("`by'"!="") {
 78.         local bylabel : label `byvar' `l', strict
 79.         di "{bf:-> by variables:} `by' = `bylabel'"
 80.     }
 81. 
.     *** Drop invalid observations ***
.     qui drop if missing(`hospitalid',`year',`class')
 82. 
.     *** Keep only the correct by-value
.     if ("`by'"!="") qui keep if `byvar'==`l'
 83. 
.     *** Run regression
.     di "run regressions residualizing dependent variable for controls"
 84.     * If absorb or tfx_resid is not empty (only one is non-empty, otherwise an error was thrown), use areg
.     if "`absorb'"!="" | "`tfx_resid'"!="" {
 85.         areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
 86.     }
 87.     * If absorb and tfx_resid are both empty, run regular regression
.     else {
 88.         reg `depvar' `controls'
 89.     }
 90. 
.     *** Predict residuals
.     sort `hospitalid' `year' `class'
 91.     * If tfx_resid is empty, predict residuals
.     if "`tfx_resid'"=="" {
 92.         predict score_r1 if e(sample),r
 93.     }
 94.     * If tfx_resid was specified, predict residuals + absorbed teacher fixed effects
.     else {
 95.         qui predict score_r1 if e(sample), dresiduals
 96.     }
 97.     ** Adjust for shrinkage target if specified
.     if "`shrinkage_target'" != "" {
 98.         reg score_r1 `shrinkage_target'
 99.         qui predict score_r if e(sample), res
100.         qui predict y_shrinktarget if e(sample), xb
101.             
.         // Check if y_shrinktarget was created successfully
.         capture confirm variable y_shrinktarget
102.         if _rc {
103.             di as error "Error: Failed to create y_shrinktarget variable"
104.             exit 111
105.         }
106.     }
107.     else {
108.         gen score_r = score_r1
109.     }
110.     qui sum score_r, detail
111. 
.     *** Save residuals to a dataset if merging them later
.     if `merge_resid'==1 {
112.         tempfile resid_data_`l'
113.         qui save `"`resid_data_`l''"', replace
114.     }
115. 
.     *** Save number of parameters
. 
.     tempname num_obs num_par
116. 
.     scalar `num_obs' = e(N)
117. 
.     * If absorb is not empty (and tfx_resid is), save (number of slopes + number of clusters + 1)
.     if "`absorb'"!="" {
118.         scalar `num_par' = e(df_m) + e(df_a) + 1
119.     }
120.     * Otherwise, save (number of slopes + 1)
.     else {
121.         scalar `num_par' = e(df_m) + 1
122.     }
123. 
.     *** Create var for number of students in class
.     tempvar n_tested
124.     qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
125.     *** Compute total variance ***
.     tempvar class_mean index mshrinktarget
126.     qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
127.     qui by `hospitalid' `year' `class': g `index' = _n
128.     if "`shrinkage_target'" != "" {
129.         qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
130.     }
131. 
.     tempname var_total
132.     qui sum score_r
133.     /// from looking I think this might var(A_it)
>     scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
134. 
.     *** Compute individual variance (i.e. within class variance)
.     *--> note that we use rmse instead of direct variance of residuals here to deal with fact that class effects have not been shrunk
.     tempname num_class var_ind var_class
135. 
.     tempvar individual_dev_from_class
136.     qui gen `individual_dev_from_class' = score_r - `class_mean'
137. 
.     qui count if `index'==1 & `n_tested'!=0
138.     scalar `num_class' = r(N)
139. 
.     qui sum `individual_dev_from_class'
140.     ///\hat{sigma_{epsilon}}^2
>     scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
141. 
. 
.     ********** Collapse to class-level data **********
. 
.     qui by `hospitalid' `year' `class': keep if _n==1
142. 
. 
.     *** Estimate covariance of two classes for same hospital in the same year
.     set seed 9827496
143.     tempvar rand classnum
144.     g `rand'=uniform()
145.     bys `hospitalid' `year' (`rand'): gen `classnum'=_n
146. 
.     * If there are multiple classes per hospital-year cell, compute the covariance.
.     * Otherwise set to 0. Will display as missing in output, but internally set to 0 because it will never appear in the VCV, but the way things are coded requires that it be n
> on-missing.
.     tempname cov_sameyear corr_sameyear obs_sameyear
147.     qui sum `classnum'
148.     if (r(max)==1) {
149.         local missing_sameyear=1
150.         scalar `cov_sameyear'=0
151.     }
152.     else {
153.         local missing_sameyear=0
154.         tempvar identifier
155.         egen `identifier'=group(`hospitalid' `year')
156.         qui tsset `identifier' `classnum' /*, noquery*/
157.         qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
158.         scalar `cov_sameyear'=r(cov_12)
159.         scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
160.         scalar `obs_sameyear'=r(N)
161.     }
162. 
.     *** Compute the variance of the class-level shock.  Hits al lkids in the class in the same way, but is unrelated across classes even taught by the same teacher in the same 
> year.
.     /// this is variance_theta
>     scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
163.     if (`var_class'<0) {
164.         di as error "Note: var_class has been computed as being less than 0."
165.         di "var_class is defined as = var_total - var_ind - cov_sameyear."
166.         di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
167.         di `var_total',`var_class',`var_ind',`cov_sameyear'
168.         di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by
> -group)."
169.     }
170. 
.     /* 2019-02-07 D.Staiger : change to code to allow us to make the M invertable using an eigen value trick.  */
.     /* This will only work when we have only one classroom per teacher (e.g. no classrooms within hospital). */
.     /* If you have multiple classrooms per teacher the code should work fine. This resets the diagonal of */
.     /* the M matrix to be our estimate of the hospital-level variance (the original code set this to 0, */
.     /* and put the hospital level variance into the class level variance (so it was part of weight). */
.     /* Now, M will be what we want (mumu), i.e. it will have a the hospital variance along the diagnol */
.     if (`missing_sameyear'==1) {
171.         scalar `cov_sameyear' = `var_class'
172.         scalar `var_class' = 0
173.     }
174.     // <END>
.     tempvar weight
175.     qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
176. 
.     *** Keep teacher-years which have no weight
. 
.     tempvar excess_weight
177.     qui gen `excess_weight'=(missing(`weight'))
178. 
.     qui replace `weight'=1 if missing(`weight')
179.     * note: adding this weight doesn't affect the class_mean, because missing observations are not included
.     * in the mean computation.  it only affects the rawsum of weight, and so we remove it afterward.
. 
. 
. ********** Collapse to teacher-year level data using precision weights **********
. if "`shrinkage_target'" != "" {
180.     collapse (mean) `class_mean' `mshrinktarget'  (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
181. }
182. else {
183.     collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
184. }
185. 
. * Remove the excess weight used to keep missing scores
. qui replace `weight'=`weight'-`excess_weight'
186. 
. ///DRIFT
> *** Estimate the covariance of years t and t+i for every i, and store in vector m
. qui tsset `hospitalid' `year'/*, noquery*/
187. 
. tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
188. 
. qui bys `hospitalid': egen `minyear'=min(`year')
189. qui by `hospitalid': egen `maxyear'=max(`year')
190. qui g `diff'=`maxyear'-`minyear'
191. qui sum `diff'
192. local maxspan=`r(max)'
193. 
. qui gen `validyear'=`year' if !missing(`class_mean')
194. qui by `hospitalid': egen `minvalidyear'=min(`validyear')
195. qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
196. qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
197. qui sum `diffvalid'
198. local maxscorespan=`r(max)'
199. 
. if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
200.     di as error _n      "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
201.     di as error         "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
202.     exit 499
203. }
204. if (`driftlimit'>`maxscorespan') {
205.     di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
206.     exit 499
207. }
208. 
. mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
209. 
. if (`driftlimit'>0)     mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
210. else                            mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
211. 
. /* Code addition by D.Staiger 2019-02-07 - to match changes made to other code.  */
. di "Standard deviations: total, classes, students, Hospital same year"
212. if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
213. else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
214. 
. /* OLD CODE */
. /* *** Print estimated variances and covariances */
. /* if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear') */
. /* else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),. */
. 
. 
. di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
215. mata:CC[.,1..3]
216. 
. di "Covariances used for VA computations:"
217. mata: m[2..length(m)]'
218. 
. if (`driftlimit'>0) {
219.     di "Drift limit specified:"
220.     di `driftlimit'
221. 
.     di "Covariances used for VA computations:"
222.     mata: m[2..length(m)]'
223. }
224. 
. mata:check_m_nomissing(m)
225. 
. *** Accumulate the estimated variances/covariances/correlations across by-vals
. if (`firstloop'==1) {
226.     mata:cov_lag_accum= CC[.,1]
227.     mata:corr_lag_accum= CC[.,2]
228.     mata:obs_lag_accum= CC[.,3]
229.     mata:cov_se_lag_accum= CC[.,4]
230.     mata:var_total_accum=       st_numscalar("`var_total'")
231.     mata:var_class_accum=       st_numscalar("`var_class'")
232.     mata:var_ind_accum= st_numscalar("`var_ind'")
233. 
.     if (`missing_sameyear'==1) {
234.         mata:cov_sameyear_accum=.
235.         mata:corr_sameyear_accum=.
236.         mata:obs_sameyear_accum=0
237.     }
238.     else {
239.         mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
240.         mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
241.         mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
242.     }
243. }
244. else {
245.     mata:cov_lag_accum=         rightAppendMatrices(cov_lag_accum,CC[.,1])
246.     mata:corr_lag_accum=        rightAppendMatrices(corr_lag_accum,CC[.,2])
247.     mata:obs_lag_accum=         rightAppendMatrices(obs_lag_accum,CC[.,3])
248.     mata:cov_se_lag_accum=      rightAppendMatrices(cov_se_lag_accum,CC[.,4])
249.     mata:var_total_accum=       var_total_accum,st_numscalar("`var_total'")
250.     mata:var_class_accum=       var_class_accum,st_numscalar("`var_class'")
251.     mata:var_ind_accum=         var_ind_accum,st_numscalar("`var_ind'")
252. 
.     if (`missing_sameyear'==1) {
253.         mata:cov_sameyear_accum= cov_sameyear_accum,.
254.         mata:corr_sameyear_accum= corr_sameyear_accum,.
255.         mata:obs_sameyear_accum= obs_sameyear_accum,.
256.     }
257.     else {
258.         mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
259.         mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
260.         mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
261.     }
262. }
263. 
. *********
. 
. * Count the number of obs for each hospital
. sort `hospitalid' `year'
264. tempvar obs_hosp
265. by `hospitalid': egen `obs_hosp'=count(`hospitalid')
266. 
. * Compute teacher VA
. qui gen float tv=.
267. 
. if ("`leaveout_years'"!="") {
268. 
.     // Call mata function with leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
269. }
270. else {
271.     // Call mata function without leaveout parameters
.     mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv")
272. }
273. 
. * Save the VA estimates to a dataset
. local shrinkage_vars_to_keep 
274. if "`shrinkage_target'" != "" {
275.     local shrinkage_vars_to_keep   `mshrinktarget'
276. }
277. local leaveout_vars_to_keep 
278. if "`leaveout_years'" != "" {
279.     local leaveout_vars_to_keep  `leaveout_vars'
280. }
281. 
. keep `hospitalid' `year' `by' tv `shrinkage_vars_to_keep' `leaveout_vars_to_keep'
282. 
. 
. 
. ///need to add back the hospital charactericis portion
> if "`shrinkage_target'" != "" {
283.     if "`leaveout_vars'" != "" {
284.         foreach v in `leaveout_vars' {
285.             gen `v'_shrinktgt =  `v' + `mshrinktarget'        
286.             replace `v'_shrinktgt=`mshrinktarget' if `v'==.
287.         }
288.     }
289.     gen shrinktarget_base=`mshrinktarget'
290. }
291. 
. if (`firstloop'!=1) {
292.     append using `"`output'"', nolabel
293. }
294. qui save `"`output'"', replace
295. 
. * Turn firstloop counter off
. local firstloop=0
296. 
. 
. di "{txt}{hline}"
297. 
. * Save VA estimates
. if "`output_addvars'"!="" quietly {
298.     restore, preserve
299.     keep `hospitalid' `year' `by' `output_addvars'
300.     bys `hospitalid' `year' `by' `output_addvars': keep if _n==1
301.     merge m:1 `hospitalid' `year' `by' using `"`output'"', nogen nolabel
302. }
303. sort `hospitalid' `year' `by'
304. qui save `"`output'"', replace
305. 
. * Save "variances / covariances / correlations" dataset to csv
. if ("`by'"!="") {
306.     local bylabels=""
307.     forvalues i=1/`by_vals' {
308.         local bylabel : label `byvar' `i', strict
309.         local bylabel=subinstr("`bylabel'"," ","_",.)
310.         local bylabels `bylabels' _`bylabel'
311.     }
312.     mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sam
> eyear_accum, obs_sameyear_accum, tokens(st_local("bylabels")))
313. }
314. else mata:saveVariancesToDataset(cov_lag_accum, corr_lag_accum, obs_lag_accum, cov_se_lag_accum, var_total_accum, var_class_accum, var_ind_accum, cov_sameyear_accum, corr_sa
> meyear_accum, obs_sameyear_accum, "")
315. if (`nooutput'!=1) qui outsheet using `"`output'_variance.csv"', comma replace
316. 
. 
. * Load the correct output dataset
. tokenize "`data'"
317. if inlist("`1'","preserve","merge") {
318.     restore
319. 
.     if (`merge_resid'==1) {
320.         if ("`byvar'"!="") qui keep if missing(`hospitalid',`year',`class',`byvar')
321.         else qui keep if missing(`hospitalid',`year',`class')
322.         forvalues l=1/`by_vals' {
323.             append using `"`resid_data_`l''"', nolabel
324.         }
325.     }
326.     if (`merge_tv'==1) qui merge m:1 `hospitalid' `year' `by' `output_addvars' using `"`output'"', nogen nolabel
327.     /* else "`data'"=="preserve", and that is already loaded. */
. }
328. else {
329.     restore, not
330. 
.     if ("`data'"=="tv") use `"`output'"', clear
331.     /* else "`data'"=="variance", and that is already loaded. */
. }
332. 
. * Close log
. if (`nooutput'!=1) log close t
333. }
334. end

. 
. 
. version 11

. set matastrict on

. 
. mata:
------------------------------------------------- mata (type end to exit) --------------------------------------------------------------------------------------------------------
:     real rowvector computeweights(real matrix M, real scalar i, real colvector c, | real colvector weights) {
>         // Add safety checks
>         if (rows(M) != cols(M)) {
>             printf("Error: Non-square matrix M (%f x %f)\n", rows(M), cols(M))
>             _error(3205, "Matrix must be square")
>         }
>         
>         if (missing(M)) {
>             printf("Warning: Matrix M contains missing values\n")
>         }
>         
>         real matrix X
>         real matrix L
>         real matrix vcv
>         real matrix Mpos
> 
>         // construct matrix A which is used to select the relevant elements of M in constructing the VCV matrix
>         real matrix temp
>         real matrix A
>         temp=designmatrix(c)
> 
>         /* ************************************************************************  */
>         /* *** Make M matrix which is off diagnol */
>         /* ************************************************************************  */
>         /* Base of code adapted from Doug Staiger, added 8/30/2019 */
>         /* NOW fix vcv so that it is pos semi def (with block/n will always */
>         /* be invertable see higham, NJ, 1988 "computing a nearest symetric */
>         /* pos sem def matrix I do this by maintianing the estimates of sd */
>         /* of each signal, and fixing the corr matrix so take pos semi def */
>         /* part of vcv, use it to estimate corr(vcv), then */
>         /* vcvpos = corr(vcv):*(sd*sd') */
>         X=.
>         L=.
>         symeigensystem(M,X,L)
>         Mpos = X*diag(L:*(L:>=0))*X'
>         /* The original code just used M everywhere, which is a matrix that is fed into this */
>         A = temp, J(rows(c),cols(Mpos)-cols(temp),0)
>         /* use A to select elements of M and build the VCV.  The second term adjusts the diagonal */
>         /* elements of the VCV matrix to account for the class-level and individual-level shocks */
>         /* We want to make the underlying signal matrix */
>         if (args()==4) vcv=A*Mpos*A' + diag(1:/weights)
>         else vcv=A*Mpos*A'
>         // phi is the vector of autocovariances, selected correctly using the matrix A.
>         real rowvector phi
>         phi=Mpos[i,.]*A'
> 
>         /* return the vector of weights, choose the VCV that D.Staiger */
>         /* coded  to always be pos semi def */
>         return    (phi*cholinv(vcv))
> }

: 
: 
: 
: real matrix compute_cov_corr(string scalar scores_var, string scalar weight_var, real scalar dim, string scalar hospitalid_var) {
> 
>     // pre-allocate matrix
>     real matrix CC
>     CC = J(dim,4,.)
> 
>     // Fill cov's and corr's: between time t and t+i
>     real scalar i
>     real scalar tstat
>     for (i=1; i<=dim; i++) {
>         // check that there are >=2 obs, in order to compute covariance
>         stata(invtokens(("quietly count if !missing(",scores_var,",f",strofreal(i),".",scores_var,")"),""))
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly corr ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cov"),""))
>             CC[i,1]=st_numscalar("r(cov_12)")
>             CC[i,2]=CC[i,1] / ( sqrt(st_numscalar("r(Var_1)")) * sqrt(st_numscalar("r(Var_2)")) )
>         }
>         CC[i,3]=st_numscalar("r(N)")
> 
>         // Compute SE for covariance estimate
>         if (st_numscalar("r(N)")>1) {
>             stata(invtokens(("quietly reg ",scores_var," f",strofreal(i),".",scores_var," [aw=",weight_var,"+f",strofreal(i),".",weight_var,"], cluster(",hospitalid_var,")"),""
> ))
>             tstat=st_matrix("e(b)")[1,1] / sqrt( st_matrix("e(V)")[1,1] )
>             CC[i,4]=abs(CC[i,1]/tstat)
>         }
>     }
> 
>     return (CC)
> }

: 
: real rowvector create_m(real colvector lag_covariances, real scalar cov_sameyear, | real scalar lagdim, real scalar driftlimit) {
>     // Add debugging
>     printf("lag_covariances dimensions: %f x %f\n", rows(lag_covariances), cols(lag_covariances))
>     printf("cov_sameyear: %f\n", cov_sameyear)
>     
>     real rowvector m
> 
>     if (args()==2)      m=cov_sameyear,lag_covariances'
> else {
>     if (length(lag_covariances)<driftlimit) _error("driftlimit specified is higher than the number of lags in the dataset")
>     m=cov_sameyear,lag_covariances'[1..driftlimit],J(1,lagdim-driftlimit,lag_covariances[driftlimit])
> }
> 
> return (m)
> }

: 
: void check_m_nomissing(real rowvector m) {
>     if (missing(m)>0) _error("covariance vector contains missing values")
> }

: 
: real matrix vectorToStripeDiag(real vector m) {
>     // Add debugging
>     printf("Input vector m dimensions: %f x %f\n", rows(m), cols(m))
>     
>     real scalar dim
>     dim = length(m)
> 
>     // pre-allocate matrix M
>     real matrix M
>     M=J(dim,dim,.)
> 
>     // fill lower triangle of M
>     real scalar i
>     real scalar j
>     for (i=1; i<=dim; i++) {
>         for (j=i; j<=dim; j++) {
>             M[j,i]=m[j-i+1]
>         }
>     }
> 
>     _makesymmetric(M)
>     return (M)
> }

: 
: real matrix rightAppendMatrices(real matrix A, real matrix B) {
>     real scalar rA
>     real scalar rB
>     rA=rows(A)
>     rB=rows(B)
> 
>     if (rA==rB)         return (A,B)
>     else if (rA<rB)     return ( ( A \ J(rB-rA,cols(A),.) ) , B )
>     else                        return ( A , ( B \ J(rA-rB,cols(B),.) ) )
> }

: 
: void saveVariancesToDataset(real matrix cov_lag_accum, real matrix corr_lag_accum, real matrix obs_lag_accum, real matrix cov_se_lag_accum, real rowvector var_total_accum, real
>  rowvector var_class_accum, real rowvector var_ind_accum, real rowvector cov_sameyear_accum, real rowvector corr_sameyear_accum, real rowvector obs_sameyear_accum, string rowve
> ctor suffixes) {
> 
>     stata("clear")
> 
>     // count number of lags, create correct number of obs, generate variable for number of lags
>     real scalar n_lags
>     n_lags=rows(cov_lag_accum)
> 
>     real scalar null
>     null=st_addvar("int","lag")
> 
>     st_addobs(n_lags)
>     stata("qui replace lag=_n")
>     st_addobs(1)
> 
>     // generate output variables
>     st_store(1::n_lags, st_addvar("float", "cov_lag":+suffixes), cov_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "corr_lag":+suffixes), corr_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "obs_lag":+suffixes), obs_lag_accum)
>     st_store(1::n_lags, st_addvar("float", "cov_se_lag":+suffixes), cov_se_lag_accum)
>     st_store(n_lags+1, st_addvar("float", "var_total":+suffixes), var_total_accum)
>     st_store(n_lags+1, st_addvar("float", "var_class":+suffixes), var_class_accum)
>     st_store(n_lags+1, st_addvar("float", "var_ind":+suffixes), var_ind_accum)
>     st_store(n_lags+1, st_addvar("float", "cov_sameyear":+suffixes), cov_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "corr_sameyear":+suffixes), corr_sameyear_accum)
>     st_store(n_lags+1, st_addvar("float", "obs_sameyear":+suffixes), obs_sameyear_accum)
> }
note: variable null set but not used.

: 
: real scalar driftcalc(real matrix M, real scalar i, real colvector c, real colvector weights, real colvector scores) {
> 
>     // b is the vector of weights
>     real rowvector b
>     b=computeweights(M, i, c, weights)
>     // return the computed tv estimate -- where it basically is summing up all the
>     // scores * weight - by matrix mulitplication of row and column vector
>     return (b*scores)
> }

: 
: 
: void driftcalclist(real matrix M, string scalar hospitalid_var, string scalar time_var, 
>     string scalar scores_var, string scalar weights_var, string scalar hospobs_var, 
>     string scalar va_var, | string scalar leaveout_years, string scalar leaveout_vars) {
>     
>     // Declare all variables upfront
>     real scalar nobs, obs, hospitalid, obs_hosp, time, new_hospitalid, new_time, year_index, i
>     real matrix Z, Z_hosp, Z_obs, Z_quasi
>     
>     nobs = st_nobs()
>     
>     // Get variable indices
>     real scalar hospitalid_var_ind, time_var_ind, hospobs_var_ind, va_var_ind
>     hospitalid_var_ind = st_varindex(hospitalid_var)
>     time_var_ind = st_varindex(time_var)
>     hospobs_var_ind = st_varindex(hospobs_var)
>     va_var_ind = st_varindex(va_var)
>     
>     // Create view of variables
>     st_view(Z=., ., (hospitalid_var, time_var, weights_var, scores_var))
>     
>     // Initialize
>     hospitalid = .
>     time = .
>     
>     // Loop over observations
>     for (obs=1; obs<=nobs; obs++) {
>         new_hospitalid = _st_data(obs, hospitalid_var_ind)
>         new_time = _st_data(obs, time_var_ind)
>         
>         // Only perform calculations for new hospital-year
>         if (new_time != time | new_hospitalid != hospitalid) {
>             time = new_time
>             
>             if (new_hospitalid != hospitalid) {
>                 hospitalid = new_hospitalid
>                 obs_hosp = _st_data(obs, hospobs_var_ind)
>                 st_subview(Z_hosp=., Z, (obs, obs+obs_hosp-1), .)
>                 year_index = min(Z_hosp[.,2])-1
>             }
>             
>             // Get observations excluding current year
>             Z_obs = select(Z_hosp, Z_hosp[.,2]:!=time)
>             Z_obs = select(Z_obs, Z_obs[.,4]:!=.)
>             
>             // Compute standard VA
>             if (rows(Z_obs) > 0) {
>                 st_store(obs, va_var_ind, 
>                     driftcalc(M, time-year_index, Z_obs[.,2]:-year_index, Z_obs[.,3], Z_obs[.,4]))
>             }
>             string vector lyears, lvars
>             lyears = tokens(leaveout_years)
>             lvars = tokens(leaveout_vars)
>             // Compute leaveout estimates if specified
>             if (args()>7) {
>                 for (i=1; i<=length(leaveout_years); i++) {
>                     string scalar before, after
>                     _parse_rule(lyears[i], before, after)
>                     
>                     // Get base observations
>         
>                     Z_quasi = Z_obs
>                     
>                     // Apply filters if valid
>                     if (before != "" & before != " ") {
>                         Z_quasi = select(Z_quasi, Z_quasi[.,2] :< (time + strtoreal(before)))
>                     }
>                     if (after != "" & after != " ") {
>                         Z_quasi = select(Z_quasi, Z_quasi[.,2] :> (time + strtoreal(after)))
>                     }
>                     
>                     if (rows(Z_quasi) > 0) {
>                         st_store(obs, st_varindex(lvars[i]), 
>                             driftcalc(M, time-year_index, Z_quasi[.,2]:-year_index, Z_quasi[.,3], Z_quasi[.,4]))
>                     }
>                 }
>             }
>         }
>     }
> }
note: variable before may be used before set.
note: variable after may be used before set.

: 
: // Helper function to parse leaveout rules
: void _parse_rule(string scalar rule, string scalar before, string scalar after) {
>     string vector parts
>     parts = tokens(rule, ",")
>     before = parts[1]
>     after = parts[3]
> }

: end
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

. 
. 
end of do-file

.         
.         * Define leave-out patterns and variable names
.         local leaveout_patterns ///
>             "-1,+1" /// Leave out t-1 and t+1
>             "-2,+2" /// Leave out t-2 and t+2
>             "-3,+1" /// Leave out t-3 and t+1
>             "-3,+2" /// Leave out t-3 and t+2
>             "-5," /// Leave out before t-5
>             ",+5" // Leave out after t+5

.             
.         local leaveout_vars ///
>             tv_tm1_t1 ///
>             tv_tm2_t2 ///
>             tv_tm3_t1 ///
>             tv_tm3_t2 ///
>             tv_tm5_t ///
>             tv_t_t5

.             
.         hospital_ebayes y, hospitalid(id) year(year) ///
>             controls(xb) shrinkage_target(z) data("merge tv") ///
>             leaveout_years("`leaveout_patterns'") ///
>             leaveout_vars("`leaveout_vars'")
  ------------------------------------------------------------------------------------------------------------------------------------------------------ begin hospital_ebayes ---
  - version 10.2
  - set more off
  - syntax varname(ts fv), hospitalid(varname) year(varname) [class(varname) by(varlist) shrinkage_target(varlist) controls(varlist ts fv) absorb(varname) tfx_resid(varname) data
> (string) output(string) output_addvars(varlist) driftlimit(integer -1) leaveout_years(string) leaveout_vars(string)]
  - if "`class'" == "" {
  = if "" == "" {
  - tempvar class_var
  - egen `class_var'=group(`hospitalid' `year')
  = egen __000000=group(id year)
  - local class `class_var'
  = local class __000000
  - }
  - local depvar `varlist'
  = local depvar y
  - capture confirm variable score_r, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named score_r."
    exit 110
    }
  - capture confirm variable tv, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory when vam is run cannot have a variable named tv."
    exit 110
    }
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - local n_rules = 0
  - foreach rule in `leaveout_years' {
  = foreach rule in -1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5 {
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-1,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_1_before "-1"
  - local rule_`n_rules'_after "`3'"
  = local rule_1_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-2,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_2_before "-2"
  - local rule_`n_rules'_after "`3'"
  = local rule_2_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+1", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_3_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_3_after "+1"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-3,+2", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_4_before "-3"
  - local rule_`n_rules'_after "`3'"
  = local rule_4_after "+2"
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize "-5,", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_5_before "-5"
  - local rule_`n_rules'_after "`3'"
  = local rule_5_after ""
  - }
  - local ++n_rules
  - tokenize "`rule'", parse(",")
  = tokenize ",+5", parse(",")
  - local rule_`n_rules'_before "`1'"
  = local rule_6_before ","
  - local rule_`n_rules'_after "`3'"
  = local rule_6_after ""
  - }
  - tokenize `leaveout_vars'
  = tokenize tv_tm1_t1             tv_tm2_t2             tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5
  - forvalues i = 1/`n_rules' {
  = forvalues i = 1/6 {
  - local var_`i' "``i''"
  = local var_1 "tv_tm1_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm1_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm1_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_2 "tv_tm2_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm2_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm2_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_3 "tv_tm3_t1"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t1, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t1 = .
  - }
  - local var_`i' "``i''"
  = local var_4 "tv_tm3_t2"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm3_t2, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm3_t2 = .
  - }
  - local var_`i' "``i''"
  = local var_5 "tv_tm5_t"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_tm5_t, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_tm5_t = .
  - }
  - local var_`i' "``i''"
  = local var_6 "tv_t_t5"
  - capture confirm variable ``i'', exact
  = capture confirm variable tv_t_t5, exact
  - if (_rc==0) {
    di as error "The dataset loaded in memory cannot have a variable named ``i''."
    exit 110
    }
  - qui gen float ``i'' = .
  = qui gen float tv_t_t5 = .
  - }
  - }
  - local merge_tv=0
  - local merge_resid=0
  - if ("`data'"=="") local data="preserve"
  = if ("merge tv"=="") local data="preserve"
  - else {
  - if !inlist("`data'","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
  = if !inlist("merge tv","preserve","tv","merge tv","merge score_r","merge tv score_r","merge score_r tv","variance") {
    di as error "Not a valid argument for data. Choose either 'preserve', 'tv', 'merge [tv AND/OR score_r]', or 'variance'."
    exit 198
    }
  - else {
  - tokenize "`data'"
  = tokenize "merge tv"
  - if ("`1'")=="merge" {
  = if ("merge")=="merge" {
  - if ("`2'"=="tv") | ("`3'"=="tv") local merge_tv=1
  = if ("tv"=="tv") | (""=="tv") local merge_tv=1
  - if ("`2'"=="score_r") | ("`3'"=="score_r") local merge_resid=1
  = if ("tv"=="score_r") | (""=="score_r") local merge_resid=1
  - }
  - }
  - }
  - if "`tfx_resid'"!="" & "`absorb'"!="" {
  = if ""!="" & ""!="" {
    di as error "Cannot specify an absorb variable and a tfx_resid variable simultaneously."
    exit 198
    }
  - if `"`output'"'=="" {
  = if `""'=="" {
  - tempfile output
  - local nooutput=1
  - }
  - else local nooutput=0
  - if (`nooutput'!=1) log using `"`output'_log"', replace name(t) text
  = if (1!=1) log using `"/var/folders/ph/j5ln2nv51nb0mbb17g555l00t24pfm/T//S_03772.000001_log"', replace name(t) text
  - if ("`by'"!="") {
  = if (""!="") {
    tempvar byvar
    egen `byvar'=group(`by'), label
    sum `byvar', meanonly
    local by_vals=`r(max)'
    }
  - else local by_vals=1
  - preserve
  - local firstloop=1
  - forvalues l=1/`by_vals' {
  = forvalues l=1/1 {
  - if (`firstloop'!=1) restore, preserve
  = if (1!=1) restore, preserve
  - di "{txt}{hline}"
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  - if ("`by'"!="") {
  = if (""!="") {
    local bylabel : label `byvar' `l', strict
    di "{bf:-> by variables:} `by' = `bylabel'"
    }
  - qui drop if missing(`hospitalid',`year',`class')
  = qui drop if missing(id,year,__000000)
  - if ("`by'"!="") qui keep if `byvar'==`l'
  = if (""!="") qui keep if ==1
  - di "run regressions residualizing dependent variable for controls"
run regressions residualizing dependent variable for controls
  - if "`absorb'"!="" | "`tfx_resid'"!="" {
  = if ""!="" | ""!="" {
    areg `depvar' `controls' , absorb(`absorb'`tfx_resid')
    }
  - else {
  - reg `depvar' `controls'
  = reg y xb

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   >  99999.00
       Model |  4019417.21         1  4019417.21   Prob > F        =    0.0000
    Residual |   104011793 3,999,998  26.0029612   R-squared       =    0.0372
-------------+----------------------------------   Adj R-squared   =    0.0372
       Total |   108031210 3,999,999  27.0078093   Root MSE        =    5.0993

------------------------------------------------------------------------------
           y | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
          xb |   1.003071   .0025513   393.16   0.000     .9980703    1.008071
       _cons |   .0285967   .0025497    11.22   0.000     .0235995    .0335939
------------------------------------------------------------------------------
  - }
  - sort `hospitalid' `year' `class'
  = sort id year __000000
  - if "`tfx_resid'"=="" {
  = if ""=="" {
  - predict score_r1 if e(sample),r
  - }
  - else {
    qui predict score_r1 if e(sample), dresiduals
    }
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - reg score_r1 `shrinkage_target'
  = reg score_r1 z

      Source |       SS           df       MS      Number of obs   = 4,000,000
-------------+----------------------------------   F(1, 3999998)   =   1426.22
       Model |  37072.7593         1  37072.7593   Prob > F        =    0.0000
    Residual |   103974720 3,999,998   25.993693   R-squared       =    0.0004
-------------+----------------------------------   Adj R-squared   =    0.0004
       Total |   104011793 3,999,999  26.0029547   Root MSE        =    5.0984

------------------------------------------------------------------------------
    score_r1 | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
           z |   .9604015   .0254308    37.77   0.000     .9105581    1.010245
       _cons |  -.0000164   .0025492    -0.01   0.995    -.0050127    .0049799
------------------------------------------------------------------------------
  - qui predict score_r if e(sample), res
  - qui predict y_shrinktarget if e(sample), xb
  - capture confirm variable y_shrinktarget
  - if _rc {
    di as error "Error: Failed to create y_shrinktarget variable"
    exit 111
    }
  - }
  - else {
    gen score_r = score_r1
    }
  - qui sum score_r, detail
  - if `merge_resid'==1 {
  = if 0==1 {
    tempfile resid_data_`l'
    qui save `"`resid_data_`l''"', replace
    }
  - tempname num_obs num_par
  - scalar `num_obs' = e(N)
  = scalar __000001 = e(N)
  - if "`absorb'"!="" {
  = if ""!="" {
    scalar `num_par' = e(df_m) + e(df_a) + 1
    }
  - else {
  - scalar `num_par' = e(df_m) + 1
  = scalar __000002 = e(df_m) + 1
  - }
  - tempvar n_tested
  - qui bys `hospitalid' `year' `class': egen `n_tested' = count(score_r)
  = qui bys id year __000000: egen __000003 = count(score_r)
  - tempvar class_mean index mshrinktarget
  - qui by `hospitalid' `year' `class': egen `class_mean' = mean(score_r)
  = qui by id year __000000: egen __000004 = mean(score_r)
  - qui by `hospitalid' `year' `class': g `index' = _n
  = qui by id year __000000: g __000005 = _n
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - qui by `hospitalid' `year' `class': egen `mshrinktarget' = mean(y_shrinktarget)
  = qui by id year __000000: egen __000006 = mean(y_shrinktarget)
  - }
  - tempname var_total
  - qui sum score_r
  - scalar `var_total' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_par'))
  = scalar __000007 = r(Var)*((__000001 - 1)/(__000001 - __000002))
  - tempname num_class var_ind var_class
  - tempvar individual_dev_from_class
  - qui gen `individual_dev_from_class' = score_r - `class_mean'
  = qui gen __00000B = score_r - __000004
  - qui count if `index'==1 & `n_tested'!=0
  = qui count if __000005==1 & __000003!=0
  - scalar `num_class' = r(N)
  = scalar __000008 = r(N)
  - qui sum `individual_dev_from_class'
  = qui sum __00000B
  - scalar `var_ind' = r(Var)*((`num_obs' - 1)/(`num_obs' - `num_class' - `num_par' + 1))
  = scalar __000009 = r(Var)*((__000001 - 1)/(__000001 - __000008 - __000002 + 1))
  - qui by `hospitalid' `year' `class': keep if _n==1
  = qui by id year __000000: keep if _n==1
  - set seed 9827496
  - tempvar rand classnum
  - g `rand'=uniform()
  = g __00000C=uniform()
  - bys `hospitalid' `year' (`rand'): gen `classnum'=_n
  = bys id year (__00000C): gen __00000D=_n
  - tempname cov_sameyear corr_sameyear obs_sameyear
  - qui sum `classnum'
  = qui sum __00000D
  - if (r(max)==1) {
  - local missing_sameyear=1
  - scalar `cov_sameyear'=0
  = scalar __00000E=0
  - }
  - else {
    local missing_sameyear=0
    tempvar identifier
    egen `identifier'=group(`hospitalid' `year')
    qui tsset `identifier' `classnum'
    qui corr `class_mean' f.`class_mean' [aw=`n_tested'+f.`n_tested'], cov
    scalar `cov_sameyear'=r(cov_12)
    scalar `corr_sameyear'=r(cov_12) / ( sqrt(r(Var_1)) * sqrt(r(Var_2)) )
    scalar `obs_sameyear'=r(N)
    }
  - scalar `var_class' = `var_total' - `var_ind' - `cov_sameyear'
  = scalar __00000A = __000007 - __000009 - __00000E
  - if (`var_class'<0) {
  = if (__00000A<0) {
    di as error "Note: var_class has been computed as being less than 0."
    di "var_class is defined as = var_total - var_ind - cov_sameyear."
    di "Computed variances: var_total, var_ind, cov_sameyear, var_class"
    di `var_total',`var_class',`var_ind',`cov_sameyear'
    di "This negative variance can occur because cov_sameyear is calculated using only the subsample of observations that teach multiple classes per year (in the same by-group)."
    }
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - scalar `cov_sameyear' = `var_class'
  = scalar __00000E = __00000A
  - scalar `var_class' = 0
  = scalar __00000A = 0
  - }
  - tempvar weight
  - qui g `weight'=1/(`var_class' + `var_ind'/`n_tested')
  = qui g __00000H=1/(__00000A + __000009/__000003)
  - tempvar excess_weight
  - qui gen `excess_weight'=(missing(`weight'))
  = qui gen __00000I=(missing(__00000H))
  - qui replace `weight'=1 if missing(`weight')
  = qui replace __00000H=1 if missing(__00000H)
  - if "`shrinkage_target'" != "" {
  = if "z" != "" {
  - collapse (mean) `class_mean' `mshrinktarget' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
  = collapse (mean) __000004 __000006 (rawsum) __00000H __000003 __00000I [aw=__00000H], by(id year ) fast
  - }
  - else {
    collapse (mean) `class_mean' (rawsum) `weight' `n_tested' `excess_weight' [aw=`weight'], by(`hospitalid' `year' `by') fast
    }
  - qui replace `weight'=`weight'-`excess_weight'
  = qui replace __00000H=__00000H-__00000I
  - qui tsset `hospitalid' `year'
  = qui tsset id year
  - tempvar minyear maxyear diff validyear minvalidyear maxvalidyear diffvalid
  - qui bys `hospitalid': egen `minyear'=min(`year')
  = qui bys id: egen __00000J=min(year)
  - qui by `hospitalid': egen `maxyear'=max(`year')
  = qui by id: egen __00000K=max(year)
  - qui g `diff'=`maxyear'-`minyear'
  = qui g __00000L=__00000K-__00000J
  - qui sum `diff'
  = qui sum __00000L
  - local maxspan=`r(max)'
  = local maxspan=19
  - qui gen `validyear'=`year' if !missing(`class_mean')
  = qui gen __00000M=year if !missing(__000004)
  - qui by `hospitalid': egen `minvalidyear'=min(`validyear')
  = qui by id: egen __00000N=min(__00000M)
  - qui by `hospitalid': egen `maxvalidyear'=max(`validyear')
  = qui by id: egen __00000O=max(__00000M)
  - qui g `diffvalid'=`maxvalidyear'-`minvalidyear'
  = qui g __00000P=__00000O-__00000N
  - qui sum `diffvalid'
  = qui sum __00000P
  - local maxscorespan=`r(max)'
  = local maxscorespan=19
  - if (`maxscorespan'<`maxspan') & (`driftlimit'<=0) {
  = if (19<19) & (-1<=0) {
    di as error _n "error: The maximum lags of teacher data is `maxspan', but the maximum lags of teacher data with class scores is `maxscorespan'."
    di as error "       You must either set driftlimit() <= `maxscorespan', or drop observations so that the spans are no longer mismatched."
    exit 499
    }
  - if (`driftlimit'>`maxscorespan') {
  = if (-1>19) {
    di as error "error: driftlimit(`driftlimit') was specified, which is greater than the number of lags (`maxscorespan') in the data."
    exit 499
    }
  - mata:CC=compute_cov_corr("`class_mean'","`n_tested'",`maxscorespan',"`hospitalid'")
  = mata:CC=compute_cov_corr("__000004","__000003",19,"id")
  - if (`driftlimit'>0) mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"),`maxspan',`driftlimit')
  = if (-1>0) mata:m=create_m(CC[.,1],st_numscalar("__00000E"),19,-1)
  - else mata:m=create_m(CC[.,1],st_numscalar("`cov_sameyear'"))
  = else mata:m=create_m(CC[.,1],st_numscalar("__00000E"))
lag_covariances dimensions: 19 x 1
cov_sameyear: 1.00053839
  - di "Standard deviations: total, classes, students, Hospital same year"
Standard deviations: total, classes, students, Hospital same year
  - if (`missing_sameyear'==0) di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = if (1==0) di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
  - else di sqrt(`var_total'),sqrt(`var_class'),sqrt(`var_ind'),sqrt(`cov_sameyear')
  = else di sqrt(__000007),sqrt(__00000A),sqrt(__000009),sqrt(__00000E)
5.098401 0 4.9993154 1.0002692
  - di "Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:"
Covariances (left), correlations (middle), observations (right).  Row i indicates the relation between year t and t+i:
  - mata:CC[.,1..3]
                  1             2             3
     +-------------------------------------------+
   1 |  .9476917857   .6312018312         76000  |
   2 |  .9044250969    .602734024         72000  |
   3 |  .8527268125   .5689088551         68000  |
   4 |  .8125903186   .5429125543         64000  |
   5 |  .7695101294    .514201128         60000  |
   6 |  .7336665729   .4905786896         56000  |
   7 |  .6927342957   .4628665781         52000  |
   8 |   .666811696   .4449626476         48000  |
   9 |  .6377754865   .4254554887         44000  |
  10 |  .6084897402   .4055486704         40000  |
  11 |  .5701441751   .3795639897         36000  |
  12 |  .5496269473   .3656412528         32000  |
  13 |  .5171823385   .3430774965         28000  |
  14 |  .4989734741   .3300388215         24000  |
  15 |  .4624820673    .305849515         20000  |
  16 |  .4413674262   .2912868009         16000  |
  17 |  .4185891693   .2773554005         12000  |
  18 |  .3995607205   .2664730047          8000  |
  19 |  .3838734619    .259079548          4000  |
     +-------------------------------------------+
  - di "Covariances used for VA computations:"
Covariances used for VA computations:
  - mata: m[2..length(m)]'
                  1
     +---------------+
   1 |  .9476917857  |
   2 |  .9044250969  |
   3 |  .8527268125  |
   4 |  .8125903186  |
   5 |  .7695101294  |
   6 |  .7336665729  |
   7 |  .6927342957  |
   8 |   .666811696  |
   9 |  .6377754865  |
  10 |  .6084897402  |
  11 |  .5701441751  |
  12 |  .5496269473  |
  13 |  .5171823385  |
  14 |  .4989734741  |
  15 |  .4624820673  |
  16 |  .4413674262  |
  17 |  .4185891693  |
  18 |  .3995607205  |
  19 |  .3838734619  |
     +---------------+
  - if (`driftlimit'>0) {
  = if (-1>0) {
    di "Drift limit specified:"
    di `driftlimit'
    di "Covariances used for VA computations:"
    mata: m[2..length(m)]'
    }
  - mata:check_m_nomissing(m)
  - if (`firstloop'==1) {
  = if (1==1) {
  - mata:cov_lag_accum= CC[.,1]
  - mata:corr_lag_accum= CC[.,2]
  - mata:obs_lag_accum= CC[.,3]
  - mata:cov_se_lag_accum= CC[.,4]
  - mata:var_total_accum= st_numscalar("`var_total'")
  = mata:var_total_accum= st_numscalar("__000007")
  - mata:var_class_accum= st_numscalar("`var_class'")
  = mata:var_class_accum= st_numscalar("__00000A")
  - mata:var_ind_accum= st_numscalar("`var_ind'")
  = mata:var_ind_accum= st_numscalar("__000009")
  - if (`missing_sameyear'==1) {
  = if (1==1) {
  - mata:cov_sameyear_accum=.
  - mata:corr_sameyear_accum=.
  - mata:obs_sameyear_accum=0
  - }
  - else {
    mata:cov_sameyear_accum=st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=st_numscalar("`obs_sameyear'")
    }
  - }
  - else {
    mata:cov_lag_accum= rightAppendMatrices(cov_lag_accum,CC[.,1])
    mata:corr_lag_accum= rightAppendMatrices(corr_lag_accum,CC[.,2])
    mata:obs_lag_accum= rightAppendMatrices(obs_lag_accum,CC[.,3])
    mata:cov_se_lag_accum= rightAppendMatrices(cov_se_lag_accum,CC[.,4])
    mata:var_total_accum= var_total_accum,st_numscalar("`var_total'")
    mata:var_class_accum= var_class_accum,st_numscalar("`var_class'")
    mata:var_ind_accum= var_ind_accum,st_numscalar("`var_ind'")
    if (`missing_sameyear'==1) {
    mata:cov_sameyear_accum= cov_sameyear_accum,.
    mata:corr_sameyear_accum= corr_sameyear_accum,.
    mata:obs_sameyear_accum= obs_sameyear_accum,.
    }
    else {
    mata:cov_sameyear_accum=cov_sameyear_accum,st_numscalar("`cov_sameyear'")
    mata:corr_sameyear_accum=corr_sameyear_accum,st_numscalar("`corr_sameyear'")
    mata:obs_sameyear_accum=obs_sameyear_accum,st_numscalar("`obs_sameyear'")
    }
    }
  - sort `hospitalid' `year'
  = sort id year
  - tempvar obs_hosp
  - by `hospitalid': egen `obs_hosp'=count(`hospitalid')
  = by id: egen __00000Q=count(id)
  - qui gen float tv=.
  - if ("`leaveout_years'"!="") {
  = if ("-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5"!="") {
  - mata: driftcalclist(vectorToStripeDiag(m), "`hospitalid'", "`year'", "`class_mean'", "`weight'", "`obs_hosp'", "tv", "`leaveout_years'", "`leaveout_vars'")
  = mata: driftcalclist(vectorToStripeDiag(m), "id", "year", "__000004", "__00000H", "__00000Q", "tv", "-1,+1 -2,+2 -3,+1 -3,+2 -5, ,+5", "tv_tm1_t1             tv_tm2_t2        
>      tv_tm3_t1             tv_tm3_t2             tv_tm5_t             tv_t_t5")
